<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Mina Graph Explorer</title>
  <link href="https://fonts.googleapis.com/css2?family=Coda&display=swap" rel="stylesheet">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <meta name="theme-color" content="#000000">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VR50WVP209"></script>
  
  
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;

      background: #fff;
      color: #eee;
    }

    * {
      box-sizing: border-box;

    }

    body {
      display: flex;
      flex-direction: column;

      background: #fff;
      color: #eee;
    } 

    #app-container {
      display: flex;
      flex-direction: row;
      height: 100vh;
    }

    #left-sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 280px;
      height: 100%;
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      background: #1e1e1e;
      z-index: 1001;
    }

    #left-sidebar.open {
      transform: translateX(0);
    }

    #left-sidebar input[type="text"],
    #left-sidebar input[type="number"],
    #left-sidebar input[type="email"],
    #left-sidebar input[type="password"],
    #left-sidebar select {
      width: 100%;
      padding: 8px 12px;
      margin-bottom: 12px;
      font-size: 14px;
      color: #eee;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      outline: none;
      transition: border-color 0.2s ease, background 0.2s ease;
      appearance: none;
    }

    #left-sidebar input[type="text"]:focus,
    #left-sidebar input[type="number"]:focus,
    #left-sidebar input[type="email"]:focus,
    #left-sidebar input[type="password"]:focus,
    #left-sidebar select:focus {
      border-color: #4fc3f7;
      background: #1e1e1e;
    }

    /* Custom arrow for number inputs (modern browsers) */
    #left-sidebar input[type="number"]::-webkit-inner-spin-button,
    #left-sidebar input[type="number"]::-webkit-outer-spin-button {
      opacity: 0.5;
      transition: opacity 0.2s ease;
    }

    #left-sidebar input[type="number"]:hover::-webkit-inner-spin-button,
    #left-sidebar input[type="number"]:hover::-webkit-outer-spin-button {
      opacity: 1;
    }

    /* Checkbox style (optional improvement) */
    #left-sidebar input[type="checkbox"] {
      accent-color: #4fc3f7;
      transform: scale(1.2);
      margin-right: 6px;
    }

    #left-sidebar label {
      font-size: 12px;
      font-weight: 600;
      color: #aaa;
      margin-bottom: 4px;
      display: block;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    #left-sidebar h2 {
      font-size: 16px;
      margin-top: 24px;
      margin-bottom: 10px;
      border-bottom: 1px solid #333;
      padding-bottom: 4px;
      color: #4fc3f7;
    }


    #app-container.sidebar-open {
      margin-left: 280px;
    }

    #main-content {
      flex-grow: 1;
      flex-shrink: 1;
      flex-basis: auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    #controls {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #222;
      z-index: 999;
      padding: 10px;
      border-radius: 8px;
    }

    #sigma-container {
      flex: 1;
      position: relative;

      background: radial-gradient(circle at center, #0f0f0f, #000000);
    }

    #date-slicer-container {
      position: relative;
      width: 100%;
      background: #1e1e1e;
      padding: 10px;
      border-top: 1px solid #444;
    }

    #side-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 100%;
      max-width: 450px;
      height: 100%;
      background: #1c1c1c;
      color: white;
      overflow-y: auto;
      padding: 20px;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 999;
    }

    #side-panel.open {
      transform: translateX(0);
    }

    #menu-toggle {
      display: block;
      position: absolute;
      top: 10px;
      left: 10px;
      background: #1e1e1e;
      border: none;
      color: white;
      font-size: 24px;
      z-index: 1002;
    }

    @media screen and (max-width: 768px) {
      #app-container {
        flex-direction: column;
      }

      #menu-toggle {
        display: block;
      }

      #sigma-container,
      #date-slicer-container {
        width: 100%;
      }

      #sigma-container {
        height: 400px;
      }

      #date-slicer-container {
        padding: 6px;
        font-size: 12px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      #date-slicer-container canvas,
      #date-slicer-container .slicer-chart,
      #date-slicer-container .slicer-histogram {
        display: none !important;
      }
    }

    body.mobile-mode #slicer-chart {
      display: none !important;
      height: 0 !important;
    }

    #tooltip {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 14px;
      pointer-events: none;
      display: none;
      z-index: 10;
    }
    #search-input, #layout-iterations, #layout-gravity, #layout-scale; #layout-width, #layout-height {
      padding: 4px 8px;
      font-size: 14px;
    }

    #side-panel h3 { margin-top: 0; }

    #side-panel button {
      background: none;
      border: none;
      color: #aaa;
      font-size: 20px;

      top: 0px;
      right: 0px;
      cursor: pointer;
    }

    #side-panel .mono,
    #side-panel .mono table,
    #side-panel .mono th,
    #side-panel .mono td {
      font-family: monospace !important;
      font-size: 9px !important;
    }

    #date-slicer-container.on-left {
      left: auto !important;
      right: 530px !important; /* 👈 positions the slicer just left of the side panel */
    }

    #date-slicer-container {
      transition: right 0.3s ease, left 0.3s ease;
    }

    .linked-node {
      cursor: pointer;
      color: #4fc3f7;
      margin: 2px 0;
    }

    .search-wrapper {
      position: relative;
      display: inline-block;
    }

    #clear-search {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: #aaa;
      font-size: 16px;
      cursor: pointer;
      display: none;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
    }

    .node-halo {
      border-radius: 50%;
      background-color: white;
      width: 12px;
      height: 12px;
      position: absolute;
      transform: translate(-50%, -50%);
      pointer-events: none;
      animation: pulse 1.5s infinite;
      z-index: 1000;
    }

    .legend-item.active {
      font-weight: bold;
      text-decoration: underline;
    }    

    #close-panel-btn {
      position: absolute;
      top: 0px;
      right: 0px;
      font-size: 36px;
      background: none;
      border: none;
      color: #ccc;
      cursor: pointer;
      z-index: 9999; /* 👈 force it on top */
    }

    #node-details {
      padding-top: 50px; /* enough room for the top button */
    }    

    #controls input,
    #controls button,
    #controls select,
    #controls label {
      height: 32px;
      line-height: 32px;
      box-sizing: border-box;
    }

    /* Optionnel : ajuster les checkboxes (qui sont plus petits) */
    #controls input[type="checkbox"] {
      height: auto;
      vertical-align: middle;
    }

    #controls button,
    #side-panel button,
    #loader-modal button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      vertical-align: middle;
      height: 32px; /* ou ta hauteur souhaitée */
      line-height: normal;
      padding: 0 12px;
    }    

    .sigma-label {
      padding: 2px 4px;
      border-radius: 4px;
      background-color: rgba(0,0,0,0.4);
      color: white;
    }

    .info-icon {
      cursor: pointer;
      font-size: 14px;
      margin-left: 5px;
      color: #4fc3f7;
    }

    #legend {
      font-family: 'Coda', sans-serif;
    }


    /* Base legend style */
    #legend.legend-box {
      position: fixed;
      top: 20px;
      left: 50px;
      background: #222;
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.6;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
      transition: left 0.3s ease;
      z-index: 998;
    }

    /* 💻 Desktop layout: shift legend if sidebar is visible */
    @media screen and (min-width: 769px) {
      #app-container.sidebar-open #legend.legend-box {
        left: 330px; /* 280px sidebar + 50px margin */
      }

      /* If sidebar is hidden (fullscreen or collapsed) */
      #app-container:not(.sidebar-open) #legend.legend-box {
        left: 50px;
      }
    }

    #date-slicer-container {
      position: absolute;
      bottom: 50px;
      right: 20px;
      width: 400px;
      background: #1e1e1e;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 0 6px rgba(0,0,0,0.4);
      z-index: 999;
    }

    #slicer-container {
      position: relative; /* 👈 no longer absolute! */
      height: auto;
    }

    #slicer-container canvas {
      width: 100% !important;
      height: 150px !important;
    }

    #slicer-range {
      margin-top: 10px;
    }

    #slicer-range .noUi-target {
      width: 100%;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
    }

    #slicer-range .noUi-base {
      width: 100%;
      left: 0;
      right: 0;
    }

    body.mobile-mode #sigma-container {
      height: calc(100vh - 90px) !important;
    }

    body.mobile-mode #date-slicer-container {
      position: absolute;
      left: 50% !important;
      transform: translateX(-50%);
      bottom: 50px !important;
      width: 80% !important;
      padding: 6px 10px;
      font-size: 12px;
      height: auto !important;
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      overflow: visible;
      flex-shrink: 1;
      min-height: 0;
    }


    body.mobile-mode #slicer-container {
      height: auto !important;
    }

    body.mobile-mode #slicer-container canvas {
      display: none !important;
      height: 0 !important;
    }

    body.mobile-mode #slicer-range {
      margin-top: 4px;
    }

    body.mobile-mode #slicer-start-label,
    body.mobile-mode #slicer-end-label {
      display: none !important;
    }   

    .noUi-handle {
      width: 12px; /* or smaller, adjust as needed */
      height: 24px;
      border-radius: 2px;
      box-shadow: none;
      background: white;
    }

    /* Override the centering offset */
    .noUi-handle-lower {
      transform: translateX(11px); /* slightly offset */
    }

    .noUi-handle-upper {
      transform: translateX(-11px); /* (12px width) - 1px gap */
    }

    #searchdiv {
      position: absolute;
      top: 100%;
      right: 0;
      background: #222;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 6px 10px;
      display: none;
      z-index: 1000;
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      margin-top: 6px;
    }

    #searchdiv input {
      padding: 6px 10px;
      font-size: 14px;
      border: none;
      outline: none;
      background: #111;
      color: white;
      border-radius: 4px;
    }

    #searchdiv button {
      background: none;
      border: none;
      color: #aaa;
      font-size: 16px;
      margin-left: 6px;
      cursor: pointer;
    }
    
  .info-icon:hover {
    color: #4fc3f7;
  }
  
  #help-overlay, #token-help-overlay {
    position: fixed;
    top: 80px;
    left: 10vw;
    right: 10vw;
    bottom: 40px;
    background-color: rgba(0, 0, 0, 0.85);
    color: white;
    z-index: 9999;
    font-size: 14px;
    padding: 30px;
    overflow-y: auto;
    box-sizing: border-box;
    display: none;
    flex-direction: column;
    border-radius: 12px;
    backdrop-filter: blur(4px);
  }

@media screen and (max-width: 768px) {
    #help-overlay, #token-help-overlay {
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 0;
    padding: 20px 16px;
    font-size: 13px;
  }

    #help-overlay h1, #token-help-overlay h1 {
    font-size: 20px;
  }

    #help-overlay ul, #token-help-overlay ul {
    padding-left: 16px;
  }

    #help-overlay button, #token-help-overlay button {
    top: 10px !important;
    right: 10px !important;
    padding: 6px 12px !important;
    font-size: 13px !important;
  }
}

  #help-overlay button, token-help-overlay button {
  position: absolute;
  top: 20px;
  right: 20px;
  background: none;
  color: white;
  border: 2px solid white;
  font-size: 16px;
  padding: 6px 14px;
  cursor: pointer;
  border-radius: 6px;
  transition: background 0.2s ease, color 0.2s ease;
}

  #help-overlay button:hover, #token-help-overlay button:hover {
  background: white;
  color: black;
}   

  #left-sidebar {
    scrollbar-width: thin;
    scrollbar-color: white transparent;
  }

  #left-sidebar::-webkit-scrollbar {
    width: 10px;
  }

  #left-sidebar::-webkit-scrollbar-track {
    background: transparent;
  }

  #left-sidebar::-webkit-scrollbar-thumb {
    background-color: white;
    border-radius: 10px;
    border: 2px solid transparent;
    background-clip: content-box;
  }
  
  #side-panel {
    scrollbar-width: thin;
    scrollbar-color: white transparent;
  }

  #side-panel::-webkit-scrollbar {
    width: 10px;
  }

  #side-panel::-webkit-scrollbar-track {
    background: transparent;
  }

  #side-panel::-webkit-scrollbar-thumb {
    background-color: white;
    border-radius: 10px;
    border: 2px solid transparent;
    background-clip: content-box;
  }
  
  #legend.legend-box {
    cursor: move;
  }

  #splash-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: black;
    z-index: 9999;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: fadeOut 0.5s ease-out 8s forwards;
  }

  .splash-content {
    text-align: center;
  }

  #splash-screen h1 {
    font-size: 48px;
    margin-top: 20px;
    opacity: 0;
    animation: fadeIn 6s ease-in-out forwards;
    animation-delay: 0.2s;
    color: #FFF;
    text-shadow:
      0 0 5px #ffffff,
      0 0 10px #ffffff,
      0 0 20px #a200ff,
      0 0 30px #a200ff,
      0 0 40px #a200ff;
  }

  #splash-screen img {
    width: 256px;
    height: 256px;
    opacity: 0;
    animation: fadeIn 4s ease-in-out forwards;
    animation-delay: 0.2s;
  }

  @keyframes fadeIn {
    to {
      opacity: 1;
    }
  }

  @keyframes fadeOut {
    to {
      opacity: 0;
      visibility: hidden;
    }
  }


  </style>
  <script src="https://cdn.jsdelivr.net/npm/sigma@2.4.0/build/sigma.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/graphology@0.26.0/dist/graphology.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata@2.0.0"></script>  
  <link href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>
  
</head>

<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("/mina-graph/service-worker.js").then(
        (reg) => console.log("ServiceWorker registered", reg),
        (err) => console.log("ServiceWorker registration failed", err)
      );
    });
  }

  <!-- Google tag (gtag.js) -->
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-VR50WVP209');

  function updateLegendOffset() {
    const legend = document.getElementById("legend");
    const appContainer = document.getElementById("app-container");
    const isWideScreen = window.innerWidth >= 769;
    const sidebarOpen = appContainer.classList.contains("sidebar-open");
    const fullscreen = document.body.classList.contains("fullscreen-mode");

    if (isWideScreen && sidebarOpen && !fullscreen) {
      legend.style.left = "330px"; // Sidebar visible
    } else {
      legend.style.left = "50px";  // Sidebar hidden or fullscreen
    }
  }
  
  function getContrastingLabelColor(bgColor) {
    if (!bgColor || typeof bgColor !== "string") return currentTheme === "light" ? "#000" : "#fff";

    // Ensure it's a valid 6-digit hex color
    if (!/^#[0-9a-fA-F]{6}$/.test(bgColor)) return currentTheme === "light" ? "#000" : "#fff";

    const r = parseInt(bgColor.substr(1, 2), 16);
    const g = parseInt(bgColor.substr(3, 2), 16);
    const b = parseInt(bgColor.substr(5, 2), 16);

    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

    return luminance > 0.6 ? "#000" : "#fff";
  }

  function getDecimalsForBlockchain(chain) {
    switch (chain) {
      case "ethereum":
      case "polygon":
        return 18;
      case "mina":
        return 9;
      default:
        return 18; // Default fallback
    }
  }

  function formatAmount(amount, decimals = 9) {
    if (!amount) return "-";
    try {
      return (parseFloat(amount) / Math.pow(10, decimals)).toFixed(2);
    } catch (e) {
      return "-";
    }
  }

  function showLoader() {
    cancelRequested = false;
    document.getElementById("loader-modal").style.display = "flex";
    document.getElementById("loader-log").textContent = "";
  }

  function hideLoader() {
    document.getElementById("loader-modal").style.display = "none";
  }

  function appendLoaderLog(message) {
    const logEl = document.getElementById("loader-log");
    const lines = logEl.textContent.trim().split("\n");
    lines.push(message);
    if (lines.length > 10) lines.shift(); // Keep max 10 lines
    logEl.textContent = lines.join("\n");
  }

  function getColorByName(name) {
    if (!name || name === "noname") return "hsl(300, 100%, 65%)";
    if (!nameColorMap.has(name)) {
      const hue = Array.from(name).reduce((acc, char) => acc + char.charCodeAt(0), 0) % 360;
      nameColorMap.set(name, `hsl(${hue}, 100%, 60%)`);
    }
    return nameColorMap.get(name);
  }

  function getBrightColorByName(name) {
    if (!name || name === "noname") return "#F984EF";
    if (!nameColorMap.has(name)) {
      const hash = Array.from(name).reduce((acc, char) => acc + char.charCodeAt(0), 0);
      const hue = hash % 360;

      // Convert HSL( hue, 100%, 65% ) to HEX:
      const hex = hslToHex(hue, 100, 65);
      nameColorMap.set(name, hex);
    }
    return nameColorMap.get(name);
  }

  // Converts HSL to HEX
  function hslToHex(h, s, l) {
    s /= 100;
    l /= 100;

    const k = n => (n + h / 30) % 12;
    const a = s * Math.min(l, 1 - l);
    const f = n =>
      Math.round(255 * (l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)))));

    return `#${[f(0), f(8), f(4)]
      .map(x => x.toString(16).padStart(2, "0"))
      .join("")}`;
  }




  function updateLayoutProgressBar(percent) {
    const bar = document.getElementById("progress-bar");
    const text = document.getElementById("progress-text");

    bar.max = 100;
    bar.value = percent;
    text.textContent = percent + "%";
  }

  function fruchtermanReingold(graph, {
    width = 2000, height = 2000,
    iterations = 5000, gravity = GRAVITY, scalingRatio = SCALINGRATIO
  } = {}) {
    const nodes = graph.nodes();
    const positions = {};
    nodes.forEach(n => positions[n] = {
      x: graph.getNodeAttribute(n, 'x') || Math.random() * width,
      y: graph.getNodeAttribute(n, 'y') || Math.random() * height
    });

    for (let iter = 0; iter < iterations && !pause; iter++) {
      const disp = {};
      nodes.forEach(v => {
        disp[v] = { x: 0, y: 0 };
        nodes.forEach(u => {
          if (u !== v) {
            const dx = positions[v].x - positions[u].x;
            const dy = positions[v].y - positions[u].y;
            const dist = Math.sqrt(dx * dx + dy * dy) + 0.01;
            const rep = scalingRatio * scalingRatio / dist;
            disp[v].x += dx / dist * rep;
            disp[v].y += dy / dist * rep;
          }
        });
      });

      graph.forEachEdge((_, __, src, tgt) => {
        const dx = positions[src].x - positions[tgt].x;
        const dy = positions[src].y - positions[tgt].y;
        const dist = Math.sqrt(dx * dx + dy * dy) + 0.01;
        const att = dist * dist / scalingRatio;
        const dxNorm = dx / dist * att;
        const dyNorm = dy / dist * att;
        disp[src].x -= dxNorm; disp[src].y -= dyNorm;
        disp[tgt].x += dxNorm; disp[tgt].y += dyNorm;
      });

      nodes.forEach(v => {
        const d = Math.sqrt(disp[v].x ** 2 + disp[v].y ** 2);
        if (d > 0) {
          positions[v].x += (disp[v].x / d) * Math.min(d, 10);
          positions[v].y += (disp[v].y / d) * Math.min(d, 10);
        }
        positions[v].x -= gravity * (positions[v].x - width / 2) * 0.01;
        positions[v].y -= gravity * (positions[v].y - height / 2) * 0.01;
      });
    }

    nodes.forEach(n => {
      graph.setNodeAttribute(n, "x", positions[n].x);
      graph.setNodeAttribute(n, "y", positions[n].y);
    });
  }

  function applyLayout() {
      const iterations = parseInt(document.getElementById("layout-iterations").value, 10) || 5000;
      const gravity = parseFloat(document.getElementById("layout-gravity").value, 10) || 0.01;
      const scale = parseFloat(document.getElementById("layout-scale").value, 10) || 1000;
      const width = parseInt(document.getElementById("layout-width").value, 10) || 2000;
      const height = parseInt(document.getElementById("layout-height").value, 10) || 2000;        
      
      pause = false;
      
      document.getElementById("layout-info").textContent =
        `▶ Applying layout: gravity=${gravity}, scale=${scale}, width=${width}, height=${height}`;
      
      //console.log(`gravity: ${gravity}`);
      
      let step = 0;

      function runLayoutStep() {
        if (pause || step >= iterations) return;

        fruchtermanReingold(graph, {
          iterations: 1,
          gravity: gravity,
          scalingRatio: scale,
          width: width,
          height: height
        });

        renderer.refresh();
        step++;

        requestAnimationFrame(runLayoutStep);
      }

      requestAnimationFrame(runLayoutStep); // Start loop

      fruchtermanReingold(graph, {
          iterations: 1,
          gravity:  gravity,
          scalingRatio: scale,
          width: width,
          height: height
      });
      renderer.refresh();
      step++;        
  };  
  
  function stopLayoutInWorker() {
    if (layoutWorker) {
      layoutWorker.terminate();
      layoutWorker = null;
      isLayoutRunning = false;

      document.getElementById("layout-progress").value = 0;
      document.getElementById("layout-progress-text").textContent = "Stopped";

      console.log("⛔ Layout stopped by user");
      // ✅ Reset previous layout since it's been cancelled
      // 🧠 Correctly track what was actually running
      previousLayout = currentLayout;
      currentLayout = null;
    }
  }


  function runLayoutInWorker() {
    const iterations = parseInt(document.getElementById("layout-iterations").value) || 5000;
    const gravity = parseFloat(document.getElementById("layout-gravity").value) || 0.01;
    const scale = parseFloat(document.getElementById("layout-scale").value) || 1000;
    const width = parseInt(document.getElementById("layout-width").value) || 2000;
    const height = parseInt(document.getElementById("layout-height").value) || 2000;

    const algorithm = document.getElementById("layout-algorithm").value;
    currentLayout = algorithm; // 🧠 store the currently launched one


    let workerFile;
    // ✅ Define settings first
    const settings = {
      iterations,
      gravity,
      scalingRatio: scale,
      width,
      height,
    };

    switch (algorithm) {
      case "fa":
        workerFile = "forceAtlas.js";
        settings.linLogMode = document.getElementById("layout-linlog")?.checked || false;
        settings.outboundAttractionDistribution = document.getElementById("layout-outbound")?.checked || false;
        break;
      case "ord":
        workerFile = "openOrd.js";
        // Ajoute ici les paramètres spécifiques à OpenOrd si besoin
        settings.edgeWeightInfluence = parseFloat(document.getElementById("layout-ewi")?.value) || 0.0;
        settings.coolingFactor = parseFloat(document.getElementById("layout-cooling")?.value) || 0.95;
        settings.attractionMultiplier = parseFloat(document.getElementById("layout-attraction")?.value) || 0.01;
        settings.repulsionMultiplier = parseFloat(document.getElementById("layout-repulsion")?.value) || 1.0;
        settings.initialClusterCount = parseInt(document.getElementById("layout-clusters")?.value) || 5;
        break;
      case "fr":
      default:
        workerFile = "fruchtermanReingold.js";
        // Aucun paramètre spécifique à ajouter ici
        break;
    }

    console.log(workerFile);

    if (layoutWorker) layoutWorker.terminate();
    isLayoutRunning = false;
    
    // 🧪 Force a refresh baseline before applying new layout
    if (previousLayout === "ord" && algorithm !== "ord") {
      console.log("Resetting positions before switching from OpenOrd to another layout...");
      graph.forEachNode(id => {
        graph.setNodeAttribute(id, "x", Math.random() * 1000 - 500);
        graph.setNodeAttribute(id, "y", Math.random() * 1000 - 500);
      });
      renderer.refresh();
    }
   
    
    layoutWorker = new Worker(`./scripts/${workerFile}`);

    const nodes = graph.nodes().map(id => ({
      id,
      x: graph.getNodeAttribute(id, "x"),
      y: graph.getNodeAttribute(id, "y")
    }));

    const edges = graph.edges().map(id => ({
      source: graph.source(id),
      target: graph.target(id),
      weight: graph.getEdgeAttribute(id, "weight") || 1 // Fallback if undefined
    }));



    layoutWorker.postMessage({ nodes, edges, settings });

    let lastRenderTime = 0;

    layoutWorker.onmessage = function (e) {
      const { type, progress, positions } = e.data;

      if (type === "progress") {
        const percent = Math.round(progress * 100);
        document.getElementById("layout-progress").value = percent;
        document.getElementById("layout-progress-text").textContent = `${percent}%`;

        const now = performance.now();
        if (now - lastRenderTime > 300) { // only update every 300ms
          for (const id in positions) {
            const { x, y } = positions[id];
            if (isNaN(x) || isNaN(y)) {
              console.warn("💥 NaN detected during OpenOrd progress:", id, positions[id]);
            }          
            graph.setNodeAttribute(id, "x", positions[id].x);
            graph.setNodeAttribute(id, "y", positions[id].y);
          }
          renderer.refresh();
          lastRenderTime = now;
        }
      }

      if (type === "done") {
        for (const id in positions) {
          const { x, y } = positions[id];
          if (isNaN(x) || isNaN(y)) {
            console.warn("💥 NaN detected in node position:", id, positions[id]);
          }        
          graph.setNodeAttribute(id, "x", positions[id].x);
          graph.setNodeAttribute(id, "y", positions[id].y);
        }
        renderer.refresh();
        
        // ✅ Terminate worker to clean up
        if (layoutWorker) {
          layoutWorker.terminate();
          layoutWorker = null;
        }

        // ✅ Reset UI state
        const layoutBtn = document.getElementById("layout-toggle-btn");
        if (layoutBtn) layoutBtn.textContent = "Apply Layout";
        isLayoutRunning = false;          
        
        // ✅ Update previousLayout state
        previousLayout = currentLayout;
        currentLayout = null;
      }
    };
  }


  function updateProgress() {
    const bar = document.getElementById("progress-bar");
    bar.max = totalSteps;
    bar.value = currentStep;
  }

  function showErrorPopup(message) {
    const popup = document.getElementById("error-popup");
    const msgBox = document.getElementById("error-message");
    msgBox.textContent = message;
    popup.style.display = "block";
  }


  async function fetchTransactionsForKey(publicKey, blockchain = selectedBlockchain, delay = 0) {
      const normalizedKey = blockchain === "polygon" ? publicKey.toLowerCase() : publicKey;
      delay = delayByBlockchain[blockchain] || delay;
      console.log("selectedBlockchain : ", selectedBlockchain);
      console.log("Normalized Key : ", normalizedKey);

      if (visitedKeys.has(normalizedKey)) return [];
      visitedKeys.add(normalizedKey);

      const limit = (normalizedKey === BASE_KEY) ? FIRST_ITERATION_LIMIT : LIMIT;

      try {
          if (delay > 0) {
              await new Promise(resolve => setTimeout(resolve, delay));
          }

          let transactions = [];

          if (blockchain === 'mina') {
          const res = await fetch("https://www.akirion.com:4664/proxy?url=https://minataur.net/api/v1/transactions", {
              method: "POST",
              headers: {
                  "Minataur-Authorization": API_TOKEN,
                  'x-api-key': '755beb7f-24bc-4ead-924c-031e89af6d89',
                  "Content-Type": "application/json"
              },
                  body: JSON.stringify({ publicKey: normalizedKey, limit })
          });

              console.log("Calling Minataur API");

          if (!res.ok) {
              throw new Error(`Minataur API error: ${res.status} ${res.statusText}`);
          }
          const json = await res.json();

          if (!json || !json.payload || !json.payload.transactions) {
              throw new Error("Unexpected response format from Minataur API");
          }

              transactions = Array.from(new Map((json.payload.transactions || []).map(tx => [tx.hash, tx])).values());

          } else if (blockchain === 'polygon') {
              const polygonscanApiKey = API_TOKEN;
              const url = `https://api.polygonscan.com/api?module=account&action=txlist&address=${normalizedKey}&startblock=0&endblock=99999999&sort=asc&page=1&offset=${limit}&apikey=${polygonscanApiKey}`;

              console.log("Calling Polygonscan API");

              const res = await fetch(url);
              if (!res.ok) {
                  throw new Error(`PolygonScan API error: ${res.status} ${res.statusText}`);
              }

              const json = await res.json();
              if (!json || json.status !== "1" || !json.result) {
                  throw new Error("Unexpected response format from PolygonScan API");
              }


              transactions = json.result.map(tx => {
                const isContractCreation = !tx.to; // ✅ Now tx is defined

                return {
                  block_id: parseInt(tx.blockNumber),
                  height: parseInt(tx.blockNumber),
                  timestamp: `${parseInt(tx.timeStamp) * 1000}`,
                  hash: tx.hash,
                  command_type: tx.input && tx.input !== "0x" ? "contract_call" : "transfer",
                  nonce: tx.nonce,
                  amount: tx.value,
                  fee: (BigInt(tx.gasUsed) * BigInt(tx.gasPrice)).toString(),
                  memo: "",
                  sequence_no: null,
                  status: tx.isError === "0" ? "applied" : "failed",
                  failure_reason: tx.isError === "0" ? null : "error",
                  confirm: null,
                  sender_id: null,
                  sender_key: tx.from.toLowerCase(),
                  receiver_key: isContractCreation ? tx.from.toLowerCase() : tx.to.toLowerCase(),
                  sender_name: "noname",
                  receiver_id: null,
                  receiver_name: isContractCreation ? "contract_creation" : "noname",
                  fee_payer_id: null,
                  fee_payer_key: tx.from.toLowerCase(),
                  fee_payer_name: null,
                  chain_status: "canonical",
                  block_hash: tx.blockHash,
                  r_thief: 0,
                  s_thief: 0,
                  r_scammer: 0,
                  s_scammer: 0,
                  r_spammer: 0,
                  s_spammer: 0
                };
              });
          } else if (blockchain === 'ethereum') {
              const etherscanApiKey = API_TOKEN;
              const url = `https://api.etherscan.com/api?module=account&action=txlist&address=${normalizedKey}&startblock=0&endblock=99999999&sort=asc&page=1&offset=${limit}&apikey=${etherscanApiKey}`;

              console.log("Calling Etherscan API");

              const res = await fetch(url);
              if (!res.ok) {
                  throw new Error(`Etherscan API error: ${res.status} ${res.statusText}`);
              }

              const json = await res.json();
              if (!json || json.status !== "1" || !json.result) {
                  throw new Error("Unexpected response format from EtherScan API");
              }


              transactions = json.result.map(tx => {
                const isContractCreation = !tx.to; // ✅ Now tx is defined

                return {
                  block_id: parseInt(tx.blockNumber),
                  height: parseInt(tx.blockNumber),
                  timestamp: `${parseInt(tx.timeStamp) * 1000}`,
                  hash: tx.hash,
                  command_type: tx.input && tx.input !== "0x" ? "contract_call" : "transfer",
                  nonce: tx.nonce,
                  amount: tx.value,
                  fee: (BigInt(tx.gasUsed) * BigInt(tx.gasPrice)).toString(),
                  memo: "",
                  sequence_no: null,
                  status: tx.isError === "0" ? "applied" : "failed",
                  failure_reason: tx.isError === "0" ? null : "error",
                  confirm: null,
                  sender_id: null,
                  sender_key: tx.from.toLowerCase(),
                  receiver_key: isContractCreation ? tx.from.toLowerCase() : tx.to.toLowerCase(),
                  sender_name: "noname",
                  receiver_id: null,
                  receiver_name: isContractCreation ? "contract_creation" : "noname",
                  fee_payer_id: null,
                  fee_payer_key: tx.from.toLowerCase(),
                  fee_payer_name: null,
                  chain_status: "canonical",
                  block_hash: tx.blockHash,
                  r_thief: 0,
                  s_thief: 0,
                  r_scammer: 0,
                  s_scammer: 0,
                  r_spammer: 0,
                  s_spammer: 0
                };
              });
          }

          console.log(transactions);

          currentStep++;
          updateProgressBar(currentStep, totalSteps);

          return transactions;
      } catch (error) {
          cancelRequested = true;
          hideLoader();
          showErrorPopup(error.message || "An unknown error occurred");
          throw error;
      }
  }

  async function buildGraphRecursively(publicKey, depth, level = 0) {
    const normalizedKey = ["polygon", "ethereum"].includes(selectedBlockchain)
      ? publicKey.toLowerCase()
      : publicKey;
      
    if (depth < 0 || visitedKeys.has(normalizedKey) || cancelRequested) return;
    while (pause) await new Promise(r => setTimeout(r, 100));
    const transactions = await fetchTransactionsForKey(normalizedKey,selectedBlockchain,1000);

    transactionsByNeighbor[normalizedKey] = transactions; // ✅ ici

    appendLoaderLog(`🔄 Loaded ${transactions.length} tx for ${normalizedKey.slice(0, 6)}…${normalizedKey.slice(-6)} at depth ${level}`);


    for (const tx of transactions) {
      const sender = tx.sender_key;
      const receiver = tx.receiver_key;
      const senderName = tx.sender_name;
      const receiverName = tx.receiver_name;

      if (!graph.hasNode(sender)) {
        graph.addNode(sender, {
          label: `${senderName !== "noname" ? senderName : "Sender"} (${sender.slice(0, 6)}…${sender.slice(-6)})`,
          name: senderName,
          color: getBrightColorByName(senderName),
          x: Math.random() * 1000, // ← assure une position aléatoire
          y: Math.random() * 1000
        });
      }

      if (!graph.hasNode(receiver)) {
        graph.addNode(receiver, {
          label: `${receiverName !== "noname" ? receiverName : "Receiver"} (${receiver.slice(0, 6)}…${receiver.slice(-6)})`,
          name: receiverName,
          color: getBrightColorByName(receiverName),
          x: Math.random() * 1000,
          y: Math.random() * 1000
        });
      }

      const edgeId = tx.hash || `${sender}-${receiver}-${tx.nonce}`;
      if (!graph.hasEdge(edgeId)) {
        const timestamp = parseInt(tx.timestamp); // parse to ensure it's a number
        graph.addEdgeWithKey(edgeId, sender, receiver, {
          label: tx.command_type,
          status: tx.chain_status,
          timestamp: timestamp, // ✅ Add timestamp here
          color: tx.chain_status === "canonical" ? "#ccc" : "#f66"
        });
      }
    }

    const newReceivers = [...new Set(transactions.map(t => t.receiver_key))];
    totalSteps += newReceivers.length;
    updateProgressBar(currentStep, totalSteps);

    for (const r of newReceivers) {
      if (cancelRequested) break;
      await buildGraphRecursively(r, depth - 1, level + 1);
    }
  }

  function applyNodeSizesByDegree() {
    graph.forEachNode(node => {
      const degree = graph.degree(node);
      graph.setNodeAttribute(node, "size", 4 + Math.sqrt(degree));
    });
  }

  function animateLayout(iterations = 200) {
    for (let i = 0; i < iterations; i++) {
      setTimeout(() => {
        fruchtermanReingold(graph, { iterations: 1 });
        renderer.refresh();
      }, i * 20);
    }
  }
  
  function deleteSelectedNode(nodeId) {
    if (!graph.hasNode(nodeId)) return;

    const neighbors = graph.neighbors(nodeId);
    const toDelete = new Set([nodeId]); // Start with selected node

    neighbors.forEach(neighbor => {
      const neighborEdges = graph.edges(neighbor);
      let connectedOutside = false;

      for (const edge of neighborEdges) {
        const other = graph.source(edge) === neighbor ? graph.target(edge) : graph.source(edge);
        if (other !== nodeId && !toDelete.has(other)) {
          connectedOutside = true;
          break;
        }
      }

      if (!connectedOutside) {
        toDelete.add(neighbor);
      }
    });

    // Drop all nodes marked for deletion
    toDelete.forEach(n => {
      if (graph.hasNode(n)) graph.dropNode(n);
    });

    selectedNode = null;
    panel.style.display = "none";
    renderer.refresh();
  }

  function updateProgressBar(step, max) {
    const bar = document.getElementById("progress-bar");
    const text = document.getElementById("progress-text");
    bar.max = max;
    bar.value = step;
    text.textContent = `${Math.round((step / max) * 100)}%`;
  }

  function isLightTheme() {
    return currentTheme === "light";
  }

  function formatTimestamp(timestamp) {
    var t = Number(timestamp);
    if (isNaN(t)) return "-";
    var date = new Date(t);
    if (isNaN(date.getTime())) return "-";
    return date.toISOString().replace(/:\d{2}\.\d{3}Z$/, "Z");
  }



  function showNodePanel(node) {
    //rebuildTransactionsByNeighbor();
    const data = graph.getNodeAttributes(node);
    const neighbors = graph.neighbors(node);
    
    document.getElementById("side-panel").classList.add("open");
    
    selectedNode = node; // Ensure selection from side panel works too

    let tx = 0, del = 0, failed = 0, sc = 0;
    graph.forEachEdge((e, attr, src, tgt) => {
      if ((src === node || tgt === node)) {
        if (attr.status !== "canonical") failed++;
        else if (attr.label === "delegation") del++;
        else if (attr.label === "payment" || attr.label === "transfer") tx++;
        else if (attr.label === "contract_call") sc++;
      }
    });

    console.log('transactionsByNeighbor keys:', Object.keys(transactionsByNeighbor));
    console.log('Looking for node:', node);
    neighbors.forEach(n => {
      console.log('Looking for neighbor:', n);
    });
    
    const html = `
      <h3>
        <a href="${getExplorerURL('account', node, selectedBlockchain)}" target="_blank" style="color:#4fc3f7">
          ${data.label}
        </a>
      </h3>      
      <button onclick="deleteSelectedNode('${node}')" style="
        margin: 5px 0;
        background: #e53935;
        color: white;
        border: none;
        padding: 4px 10px;
        border-radius: 4px;
        cursor: pointer;
      ">🗑️ Delete this node from the Graph</button>         
      <p><strong>Key:</strong> <span style="font-size: 10px;">${node}</span></p>
      <p><strong>Degree:</strong> ${graph.degree(node)}</p>
      <p><strong>#Transactions:</strong> ${tx}</p>
      <p><strong>#Delegations:</strong> ${del}</p>
      <p><strong>#Smart Contracts:</strong> ${sc}</p>
      <p><strong>#Failed Transactions:</strong> ${failed}</p>
      <p><strong>Linked Nodes & Transactions:</strong></p>
      <div>
        ${neighbors.map(n => {
          const label = graph.getNodeAttribute(n, 'label');

          // Transactions initiées par le voisin vers le nœud sélectionné
          /*const fromNeighbor = (transactionsByNeighbor[n.toUpperCase()] || []).filter(tx =>
            (tx.sender_key.toUpperCase() === n.toUpperCase() && tx.receiver_key.toUpperCase() === node.toUpperCase()) ||
            (tx.receiver_key.toUpperCase() === n.toUpperCase() && tx.sender_key.toUpperCase() === node.toUpperCase())
          );*/
          
          const fromNeighbor = (transactionsByNeighbor[n] || []).filter(tx =>
            tx.sender_key === n && tx.receiver_key === node ||
            tx.receiver_key === n && tx.sender_key === node
          );

          console.log('node:', node);
          console.log('transactionsByNeighbor[node]:', transactionsByNeighbor[node]);

          // Transactions initiées par le nœud sélectionné vers ce voisin
          /*const fromNode = (transactionsByNeighbor[node.toUpperCase()] || []).filter(tx =>
            (tx.sender_key.toUpperCase() === n.toUpperCase() && tx.receiver_key.toUpperCase() === node.toUpperCase()) ||
            (tx.receiver_key.toUpperCase() === n.toUpperCase() && tx.sender_key.toUpperCase() === node.toUpperCase())
          );*/
          
          const fromNode = (transactionsByNeighbor[node] || []).filter(tx =>
            tx.sender_key === n && tx.receiver_key === node ||
            tx.receiver_key === n && tx.sender_key === node
          );

          console.log(fromNode);

          // Concatène et déduplique (via hash par exemple si dispo)
          const interactions = [...fromNeighbor, ...fromNode];
          const unique = Array.from(new Map(interactions.map(tx => [tx.hash, tx])).values());

          const txTable = unique.length > 0 ? `
            <table style="width:100%; border-collapse: collapse; font-size: 9px; margin-bottom: 20px;">
              <thead>
                <tr>
                  <th style="text-align:left;">Timestamp</th>
                  <th>Block</th>
                  <th>Type</th>
                  <th>Amount</th>
                  <th>Fee</th>
                  <th>Status</th>
                  <!--<th>Chain</th>-->
                </tr>
              </thead>
              <tbody>
                ${unique.map(tx => `
                  <tr title="${tx.memo || ''}">
                    <td>${formatTimestamp(tx.timestamp)}</td>
                    <td>
                      ${tx.block_id
                        ? `<a href="${getExplorerURL('block', tx.block_hash, selectedBlockchain)}" target="_blank" rel="noopener noreferrer" style="color: white; text-decoration: none;">
                            ${tx.block_id}
                          </a> <span style="font-size: 9px; opacity: 0.7;">🔗</span>`
                        : "-"}
                    </td>
                    <td>
                      ${tx.command_type
                        ? `<a href="${getExplorerURL('transaction', tx.hash, selectedBlockchain)}" target="_blank" rel="noopener noreferrer" style="color: white; text-decoration: none;">
                            ${tx.command_type} <span style="font-size: 9px; opacity: 0.7;">🔗</span>
                          </a>`
                        : (tx.label || "-")}
                    </td>
                    <td>${formatAmount(tx.amount, getDecimalsForBlockchain(selectedBlockchain))}</td>
                    <td>${formatAmount(tx.fee, getDecimalsForBlockchain(selectedBlockchain))}</td>
                    <td>${tx.status || "-"}</td>
                    <!--<td>${tx.chain_status || "-"}</td>-->
                  </tr>
                  `).join("")}
              </tbody>
            </table>
          ` : `<p style="color:#888; margin-bottom: 16px;">No direct interactions.</p>`;

          return `
            <div style="margin-bottom: 20px;">
              <div class="linked-node" onclick="showNodePanel('${n}')">${label}</div>
              <div class="mono">
                ${txTable}
              </div>
            </div>
          `;
        }).join('')}
      </div>`;
      
    details.innerHTML = html;
    panel.style.display = "flex";
    document.getElementById("date-slicer-container").classList.add("on-left");
    
    renderer.refresh(); // ✅ ensures selection is visible immediately

  }    
</script>  

<script>
  function initRenderer() {
    const container = document.getElementById("sigma-container");
    
    // ⛔ Block init if container is not visible
    if (!container.offsetWidth || !container.offsetHeight) {
      console.warn("Sigma container not ready. Retrying in 100ms...");
      setTimeout(initRenderer, 100); // retry later
      return;
    }    
    
    graph = new Graph({ multi: true });
    //console.log("Dans InitRenderer - isLightTheme = " + isLightTheme())
    param = {labelColor: {color: isLightTheme() ? "#000" : "#9999ff"}}
    
    //renderer = new Sigma(graph, container);

    renderer = new Sigma(graph,container,param);

    // Re-apply settings and listeners
    setupReducers();
    setupInteractions();
    setupSearch();
  }

  function setupReducers() {
    renderer.setSetting("nodeReducer", (node, data) => {
      const focusNode = hoveredNode || selectedNode;
      const neighbors = focusNode ? new Set(graph.neighbors(focusNode)) : null;
      const isFocus = focusNode === node;
      const isNeighbor = neighbors?.has(node);
      //console.log("getBrightColorByName " + data.name); 
      const glowColor =  getBrightColorByName(data.name || "noname");
      const defaultSize = data.size || 5;
      //console.log("Dans nodeReducer - isLightTheme = " + isLightTheme())


      // 🎯 Filter by command type
      const visibleTypes = expandedCommandTypeFilter();

      if (visibleTypes.size > 0) {
        const hasVisibleEdge = graph.edges(node).some(e => {
          const command = graph.getEdgeAttribute(e, "command_type") || graph.getEdgeAttribute(e, "label");
          return visibleTypes.has(command);
        });

        if (!hasVisibleEdge) {
          return {
            ...data,
            color: isLightTheme() ? "#eee" : "#111",
            label: "",
            labelSize: 36,
            hidden: false,
            opacity: 0.05,
            size: defaultSize * 0.1, //* 0.7,
            borderSize: 0,
            zIndex: 0
          };
        }
      }

      // ✨ Focus or neighbor styling
      if (focusNode) {
        if (isFocus) {
          //console.log ("Node Focused");
          return {
            ...data,
            type: "circle",
            color: glowColor,
            overrideColor: glowColor, // 🟢 force Sigma to use this color
            label: data.label,
            labelSize: 36,
            labelColor: {color: "#000"},
            forceLabelColor: true,
            //labelBackground: {
            //  color: currentTheme === "light" ? "#000" : "#fff",
            //  opacity: 0.6,
            //  padding: 3,
            //  borderRadius: 4,
            //},  
            //forceLabelBackground: true,
            zIndex: 2,
            size: defaultSize * 2.2,
            borderColor: glowColor,
            borderSize: 6,
            opacity: 0.9,
          };
        }

        if (isNeighbor) {
          return {
            ...data,
            type: "circle",
            color: glowColor,
            overrideColor: glowColor, // 🟢 force Sigma to use this color
            label: showAllLabels ? data.label : "",
            labelSize: 36,
            // 👇 Force label color
            labelColor: {color: isLightTheme() ? "#000" : "#fff"},
            forceLabelColor: true,
            labelBackground: {
              color: currentTheme === "light" ? "#000" : "#fff",
              opacity: 0.6,
              padding: 3,
              borderRadius: 4,
            },  
            forceLabelBackground: true,                
            zIndex: 1,
            size: defaultSize * 1.5,
            borderColor: glowColor,
            borderSize: 4,
            opacity: 0.5,
          };
        }

        // Dim unrelated nodes
        return {
          ...data,
          color: isLightTheme() ? "#eee" : "#111",
          labelColor: {color: isLightTheme() ? "#000" : "#fff"},
          label: "",
          labelSize: 36,
          size: defaultSize * 0.7,
          opacity: 0.1,
          borderSize: 0,
          zIndex: 0
        };
      }

      // 🧩 Default view
      return {
        ...data,
        color: glowColor,
        overrideColor: glowColor, // 🟢 force Sigma to use this color
        borderColor: glowColor,
        borderSize: 4,
        opacity: 0.75,
        label: showAllLabels ? data.label : "",
        // 👇 Force label color
        labelColor: {color: isLightTheme() ? "#000" : "#fff"},
        forceLabelColor: true,
        //labelBackground: {
        //  color: currentTheme === "light" ? "#000" : "#fff",
        //  opacity: 0.6,
        //  padding: 3,
        //  borderRadius: 4,
        //},
        labelSize: 36,
        //forceLabelBackground: true,          
        size: defaultSize,
        zIndex: 1
      };
    });
    
    renderer.setSetting("defaultNodeColor", "#fff"); // or any default fallback


    renderer.setSetting("edgeReducer", (edge, data) => {
      const focusNode = hoveredNode || selectedNode;
      const command = data.command_type || data.label;
      //console.log("Dans edgeReducer - isLightTheme = " + isLightTheme())
      let baseColor = "#666";
      switch (command) {
        case "payment": baseColor = "#4caf50"; break;
        case "transfer": baseColor = "#4caf50"; break;
        case "delegation": baseColor = "#2196f3"; break;
        case "zkapp": baseColor = "#ff57c1"; break;
        case "contract_call": baseColor = "#ff57c1"; break;
      }

      // 🧊 Filter edges
      const visibleTypes = expandedCommandTypeFilter();
      if (visibleTypes.size > 0 && !visibleTypes.has(command)) {
        return {
          ...data,
          color: isLightTheme() ? "#eee" : "#111",
          size: 0.3,
          opacity: 0.05,
          zIndex: 0
        };
      }

      if (focusNode) {
        const source = graph.source(edge);
        const target = graph.target(edge);
        const neighbors = new Set(graph.neighbors(focusNode));

        const isFocusEdge =
          (source === focusNode && neighbors.has(target)) ||
          (target === focusNode && neighbors.has(source));

        if (isFocusEdge) {
          return {
            ...data,
            color: baseColor,
            size: 1.5,
            opacity: 0.6,
            zIndex: 2
          };
        } else {
          return {
            ...data,
            color: isLightTheme() ? "#eee" : "#111",
            size: 0.4,
            opacity: 0.1,
            zIndex: 0
          };
        }
      }

      // 🌐 Default
      return {
        ...data,
        color: baseColor,
        size: 0.8,
        opacity: 0.3,
        zIndex: 0
      };
    });
  }



  function setupInteractions() {
    renderer.on("enterNode", ({ node }) => {
      hoveredNode = node;
      tooltip.style.display = "block";
      tooltip.innerText = graph.getNodeAttribute(node, "label");
      
      const pos = renderer.getNodeDisplayData(node);
      const halo = document.createElement("div");
      halo.className = "node-halo";
      halo.style.left = `${pos.x}px`;
      halo.style.top = `${pos.y}px`;
      halo.id = "node-halo";
      document.getElementById("sigma-container").appendChild(halo);        
      
      renderer.refresh();
    });

    renderer.on("leaveNode", () => {
      hoveredNode = null;
      tooltip.style.display = "none";
      const halo = document.getElementById("node-halo");
      if (halo) halo.remove();        
      renderer.refresh();
    });

    renderer.on("clickNode", ({ node }) => {
      selectedNode = node;
      showNodePanel(node);
      renderer.refresh();
    });

    renderer.on("clickStage", () => {
      hideNodePanel();
    });

    
    if (renderer) {
      renderer.getContainer().addEventListener("mousemove", e => {
        tooltip.style.left = e.pageX + 10 + "px";
        tooltip.style.top = e.pageY + 10 + "px";
      });
    }
  }

  function setupSearch() {
    const searchInput = document.getElementById("search-input");
    const clearBtn = document.getElementById("clear-search");

    searchInput.addEventListener("input", e => {
      const query = e.target.value.toLowerCase();
      clearBtn.style.display = query ? "block" : "none";

      if (!query) {
        selectedNode = null;
        panel.style.display = "none";
        renderer.refresh();
        return;
      }

      const match = graph.nodes().find(n =>
        graph.getNodeAttribute(n, "label").toLowerCase().includes(query)
      );

      selectedNode = match || null;

      if (match) {
        //showNodePanel(match);
        //panel.style.display = "flex";
      } else {
        panel.style.display = "none";
      }

      renderer.refresh();
    });
    
    document.getElementById("search-icon").addEventListener("click", () => {
      const searchDiv = document.getElementById("searchdiv");
      const input = document.getElementById("search-input");
      const searchVisible = searchDiv.style.display === "block" ? false : true;
      searchDiv.style.display = searchVisible ? "none" : "block";
      input.style.display = searchVisible ? "none" : "block";
      if (searchVisible) input.focus();
    });
    

    clearBtn.addEventListener("click", () => {
      searchInput.value = "";
      selectedNode = null;
      clearBtn.style.display = "none";
      panel.style.display = "none";
      renderer.refresh();
    });
  }  
  
  async function main(depth = 2) {
    showLoader(); // ✅ show modal

    totalSteps = 1;
    currentStep = 0;
    visitedKeys.clear();

    // Rebuild the graph object BEFORE rendering
    graph = new Graph({ multi: true });

    await buildGraphRecursively(BASE_KEY, depth);

    applyNodeSizesByDegree();
    //fruchtermanReingold(graph);

    // Only now, create the renderer
    const container = document.getElementById("sigma-container");
    container.innerHTML = ""; // ✅ clears canvas and attached DOM elements
    tooltip.style.display = "none";
    panel.style.display = "none";
    hoveredNode = null;
    selectedNode = null;      

    param = {labelColor: {color: isLightTheme() ? "#000" : "#9999ff"}}
    
    //renderer = new Sigma(graph, container);

    renderer = new Sigma(graph,container,param);
   
    // Apply reducers and interactions
    setupReducers();
    setupInteractions();
    setupSearch();

    renderer.refresh();
    
    animateLayout();
    
    hideLoader(); // ✅ hide modal
    
    setTimeout(() => updateProgressBar(0, 1), 500); // clear bar after delay
    
    setupDateSlicer();  // 👈 à ajouter à la fin de main()
    
  }




  function exportJSON() {
    const json = {
      nodes: graph.nodes().map(n => ({ id: n, ...graph.getNodeAttributes(n) })),
      edges: graph.edges().map(e => ({
        id: e,
        source: graph.source(e),
        target: graph.target(e),
        ...graph.getEdgeAttributes(e)
      }))
    };
    const blob = new Blob([JSON.stringify(json, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "mina-graph.json";
    a.click();
  }

  function importJSON(file) {
    if (!graph || !renderer) {
      initRenderer();
    }
 
    hoveredNode = null;
    selectedNode = null;

    const reader = new FileReader();
    const progressBar = document.getElementById("progress-bar");

    reader.onload = function (event) {
      try {
        const data = JSON.parse(event.target.result);

        if (!data.nodes || !data.edges) {
          alert("Invalid JSON format (missing 'nodes' or 'edges')");
          return;
        }

        graph.clear();
        const total = data.nodes.length + data.edges.length;
        let current = 0;
        updateProgressBar(current, total);

        data.nodes.forEach((n) => {
          graph.addNode(n.id, n);
          current++;
          updateProgressBar(current, total);
        });

        data.edges.forEach((e) => {
          if (e.timestamp) {
            e.timestamp = parseInt(e.timestamp); // 🛠️ Convert back to number
          }        
          graph.addEdgeWithKey(e.id, e.source, e.target, e);
          current++;
          updateProgressBar(current, total);
        });

        applyNodeSizesByDegree();     // reuse your logic
        //fruchtermanReingold(graph);   // optional
        renderer.refresh();

        // Reset bar
        setTimeout(() => {
          progressBar.value = 0;
          document.getElementById("progress-text").textContent = "";
        }, 300);

        alert("Graph imported successfully!");
        rebuildTransactionsByNeighbor();
        setupDateSlicer();
      } catch (e) {
        console.error("Failed to load graph JSON:", e);
        alert("Failed to load graph JSON. See console for details.");
      }
    };

    reader.readAsText(file);
  }


  function exportPNG() {
    const canvas = document.querySelector("canvas");
    const img = canvas.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = img;
    a.download = "mina-graph.png";
    a.click();
  }    
</script>

<body>
  <button id="menu-toggle">☰</button>
  <div id="app-container">
    <div id="left-sidebar" style="
      width: 280px;
      background: #1e1e1e;
      color: white;
      padding: 20px;
      overflow-y: auto;
      font-family: sans-serif;
      border-right: 1px solid #444;
    "><br/>
      <h2 style="font-size: 16px; margin-bottom: 10px;">Blockchain</h2>
      <label for="blockchain-select">Select Blockchain</label>
      <select id="blockchain-select" style="margin-bottom: 20px;">
        <option value="mina" selected>Mina Protocol</option>
        <option value="ethereum">Ethereum</option>
        <option value="polygon">Polygon</option>
      </select>

      <h2 style="font-size: 16px; margin-bottom: 10px;">Fetch Parameters</h2>
      <label>LIMIT<br /><input id="param-limit" type="number" value="80" style="width: 100%; margin-bottom: 10px;"></label>
      <label>FIRST ITERATION LIMIT<br /><input id="param-first-iteration" type="number" value="1000" style="width: 100%; margin-bottom: 10px;"></label>
      <label>RECURSION DEPTH<br /><input id="param-depth" type="number" value="2" style="width: 100%; margin-bottom: 10px;"></label>
      <label>START KEY<br /><input id="param-base-key" type="text" value="B62..." style="width: 100%; margin-bottom: 10px;"></label>
      <label>API KEY
      <span 
        onclick="document.getElementById('token-help-overlay').style.display = 'block';" 
        title="Click for more info" 
        style="cursor: pointer; margin-left: 5px; vertical-align: middle;"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
          <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/>
        </svg>
      </span>       
      <br />
      <b style="font-size:9px; color:#FF3333;">TRIAL PERIOD - NO TOKEN REQUIRED FOR MINA</b>
        <input id="param-api-token" type="password" value="" style="width: 100%; margin-bottom: 20px;">
      </label>
      <button id="toggle-token-section" style="width: 100%; margin-bottom: 10px; padding: 8px; cursor: pointer; background: #4fc3f7; color: white; border: none; border-radius: 4px;">
      <span id="toggle-token-arrow">▸</span> Get new API token
      <span class="info-icon" title="This tool requires a Minataur API Token.&#10;&#10;To get one, send 1 MINA to the Minataur API address:&#10;B62qk3SwELMgRYALi8fiQvpqfBs48m3cqCd7o4d5dJUqEQ6mW9gEySm&#10;and include your email in the memo field.&#10;&#10;Once confirmed, you'll receive your token by email.&#10;Tokens are valid for 3 days. You can request new ones as needed.&#10;&#10;More info: https://minataur.net/api/restful">
      <span style="font-size:18px; color: white; opacity: 1;">ℹ</span>
      </span>
      </button>
      <div id="minataur-token-section" style="display: none; margin-bottom: 20px;">
        <input id="minataur-email" type="email" placeholder="Enter your email to receive your token" style="width: 100%; margin-bottom: 10px;" />
        <button id="connect-auro-btn" style="width: 100%; background: #4caf50; color: white; padding: 8px; border: none; border-radius: 4px;">Request Token (Auro Wallet required)</button>
      </div>
      
      <hr/>

      <div>
          <label>&nbsp;</label><br />
          <button id="start-graph-btn" style="width: 100%; margin-bottom: 20px; padding: 8px; cursor: pointer; background: #444; color: white; border: none; border-radius: 4px;">Start</button>
      </div>
      <h2 style="font-size: 16px; margin-bottom: 10px;">Graph Parameters</h2>
     
      <label for="layout-algorithm">ALGORITHM</label>
      <select id="layout-algorithm">
        <option value="fr" selected>Fruchterman-Reingold</option>
        <option value="fa">ForceAtlas2</option>
        <option value="ord">OpenOrd</option>
      </select>
      
      <!-- ForceAtlas2-only settings -->
      <div id="forceatlas-settings" style="display: none; margin-top: 10px;">
        <label>
          <input type="checkbox" id="layout-linlog" />
          LinLog Mode
        </label>
        <br />
        <label>
          <input type="checkbox" id="layout-outbound" />
          Outbound Attraction Dist.
        </label>
        <br/>
      </div>      
      
      <div id="openord-settings" style="display: none;">
        <label>Edge Weight Influence <input id="layout-ewi" type="number" min="0" max="2" step="0.1" value="0.0"></label>
        <label>Cooling Factor <input id="layout-cooling" type="number" min="0.5" max="1" step="0.01" value="0.95"></label>
        <label>Attraction Multiplier <input id="layout-attraction" type="number" min="0.01" max="1" step="0.01" value="0.01"></label>
        <label>Repulsion Multiplier <input id="layout-repulsion" type="number" min="0.1" max="10" step="0.1" value="1.0"></label>
        <label>Initial Cluster Count <input id="layout-clusters" type="number" min="1" max="20" step="1" value="5"></label>
      </div>
      
      
      <label>GRAPH LAYOUT ITERATIONS<br /><input id="layout-iterations" type="number" value="5000" style="width: 100%; margin-bottom: 10px;"></label>
      <label>WIDTH<br /><input id="layout-width" type="number" step="100" value="2000" style="width: 100%; margin-bottom: 10px;"></label>
      <label>HEIGHT<br /><input id="layout-height" type="number" step="100" value="2000" style="width: 100%; margin-bottom: 10px;"></label>
      <label>GRAVITY<br /><input id="layout-gravity" type="number" step="0.01" value="0.01" style="width: 100%; margin-bottom: 10px;"></label>
      <label>SCALE<br /><input id="layout-scale" type="number" step="10" value="1000" style="width: 100%; margin-bottom: 10px;"></label>
      <input type="checkbox" id="toggle-labels" checked style="vertical-align: middle;">
      <label for="toggle-labels" style="color:#aaa; display: inline-block; margin-left: 5px; vertical-align: middle;">SHOW LABELS</label><br/><br/>
      <button id="layout-toggle-btn"
        style="width: 100%; margin-bottom: 20px; padding: 8px; cursor: pointer; background: #444; color: white; border: none; border-radius: 4px;">
        Apply Layout
      </button>
      <div id="layout-progress-wrapper" style="margin-top: 20px;">
        <label style="color:#aaa;">Layout progress</label>
        <progress id="layout-progress" value="0" max="100" style="width: 100%;"></progress>
        <div id="layout-progress-text" style="font-size: 13px; color: #aaa; text-align: right; margin-top: 4px;">0%</div>
      </div>
      <h2 style="font-size: 16px; margin-bottom: 10px;">Load / Save</h2>
      <button onclick="exportJSON()" style="width: 100%; margin-bottom: 10px; padding: 8px; cursor: pointer; background: #444; color: white; border: none; border-radius: 4px;">EXPORT JSON</button>
      <button onclick="document.getElementById('import-json').click()" style="width: 100%; margin-bottom: 10px; padding: 8px; cursor: pointer; background: #444; color: white; border: none; border-radius: 4px;">IMPORT JSON</button>
      <input type="file" id="import-json" accept=".json" style="display: none;">
      <button onclick="exportPNG()" style="width: 100%; margin-bottom: 10px; padding: 8px; cursor: pointer; background: #444; color: white; border: none; border-radius: 4px;">EXPORT PNG</button>
      <div style="margin-top: 40px; text-align: center;">
        <a href="#" onclick="document.getElementById('help-overlay').style.display='flex'" style="color: #4fc3f7; text-decoration: underline; font-size: 14px;">How does this work?</a>
      </div>  
      <div style="margin-top: 10px;">
        <div style="display: flex; align-items: center; gap: 6px; font-size: 10px; margin-top: 10px; color: #ccc;">
          <label style="margin: 0;font-size:9px;">Buy me a coffee (or a Lamborghini 😊)</label>
          <span class="info-icon" title="Support this project by sending any amount of MINA via Auro Wallet." style="cursor: help; font-size: 14px; opacity: 1;">
            ℹ
          </span>
        </div>
        <input id="donation-amount" type="number" min="0.1" step="0.1" placeholder="Amount in MINA" style="width: 100%; margin-bottom: 10px;" />
        <button id="donate-btn" style="width: 100%; background: #ff9800; color: white; padding: 8px; border: none; border-radius: 4px;">
          Donate with Auro Wallet
        </button>
      </div>
    </div>


    <!-- Make sure the graph container has margin-left to not overlap the sidebar -->
    <div id="main-content">
      <div id="controls">
        <div style="min-width: 200px;display: none;">
          <label style="color:#aaa;">Layout info</label><br />
          <span id="layout-info" style="display:inline-block; min-width: 180px;"></span>
        </div>
        
        <div style="flex: 1; min-width: 100px;display:none;">
          <label for="progress-bar" style="color:#aaa;">Progress</label><br />
          <progress id="progress-bar" value="0" max="100" style="width: 100%;"></progress>
        </div>
        
        <div style="min-width: 60px;display: none;">
          <label style="color:#aaa;">&nbsp;</label><br />
          <span id="progress-text" style="display:none;"></span>
        </div>

        <!-- Floating search input -->
        <div id="searchdiv" class="search-wrapper" style="display: none;">
          <input id="search-input" type="text" placeholder="Search node..." />
          <button id="clear-search">×</button>
        </div>

        <button id="search-icon" title="Search" style="background: none; border: none; cursor: pointer;">
          <svg id="search-icon-svg" viewBox="0 0 24 24" width="24" height="24">
            <path d="M15.5,14h-0.79l-0.28-0.27c1.01-1.18,1.63-2.71,1.63-4.38
              C16.06,6.47,13.59,4,10.53,4S5,6.47,5,9.53S7.47,15.06,10.53,15.06
              c1.67,0,3.2-0.62,4.38-1.63l0.27,0.28v0.79l4.25,4.25
              c0.41,0.41,1.08,0.41,1.49,0s0.41-1.08,0-1.49L15.5,14z
              M10.53,13.06c-1.95,0-3.53-1.58-3.53-3.53s1.58-3.53,3.53-3.53
              s3.53,1.58,3.53,3.53S12.48,13.06,10.53,13.06z"/>
          </svg>
        </button>


        <div style="display:none;">
          <label>&nbsp;</label><br />
          <button onclick="pause = !pause">Pause/Resume</button>
        </div>

          <button id="theme-toggle-btn" title="Toggle theme" style="background: none; border: none; cursor: pointer;">
            <span id="theme-icon">
              <!-- SVG moon (default dark theme) -->
              <svg viewBox="0 0 24 24" width="24" height="24" style="fill:white;">
                <path fill="white" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"/>
              </svg>
            </span>
          </button>



          <button id="fullscreen-toggle" style="
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            white-space: nowrap;
          ">
            ⛶
          </button>
        </div>


       <div id="sigma-container"></div>  
       </div>
      </div>
      <!-- SLICER CONTAINER -->
      <div id="date-slicer-container" >
<!--style="
        position: absolute;
        bottom: 60px;
        right: 30px;
        background: rgba(0, 0, 0, 0.85);
        padding: 14px;
        border-radius: 8px;
        color: white;
        font-size: 13px;
        width: 360px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
      "      -->
        <!--<strong style="display: block; margin-bottom: 8px;">Filter by Transaction Date</strong>-->
        
        <div id="slicer-container" style="width: 100%; height: 140px;">
          <canvas id="slicer-chart" style="width: 100%; height: 100%; display: block;"></canvas>    
        </div>

        <div id="slicer-range" style="margin-top: 12px;"></div>  

        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 10px;">
          <span id="slicer-start-label">From: --</span>
          <span id="slicer-end-label">To: --</span>
        </div>
      </div>
  </div>    
  
    <div id="side-panel">
      <button id="close-panel-btn" onclick="hideNodePanel()">&times;</button>
      <div id="node-details"></div>
    </div>
    
    <div id="tooltip"></div>
   
     <!-- Help overlay -->
    <div id="help-overlay">
      <button onclick="document.getElementById('help-overlay').style.display='none'" style="
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        color: white;
        border: 2px solid white;
        font-size: 18px;
        padding: 8px 16px;
        cursor: pointer;
        border-radius: 5px;
      ">CLOSE</button>
      <h1>How does this work?</h1>
        <p style="font-size: 18px; line-height: 1.6;">
          This tool lets you explore Mina blockchain graphs interactively by fetching and visualizing account transactions as nodes and links.
        </p>
        <ul style="font-size: 16px; line-height: 1.8;">
          <li><strong>LIMIT</strong>: Max number of transactions to fetch per key (after the first).</li>
          <li><strong>FIRST ITERATION LIMIT</strong>: Max transactions for the root key.</li>
          <li><strong>RECURSION DEPTH</strong>: How many levels of linked accounts to explore.</li>
          <li><strong>START KEY</strong>: The public key where exploration begins.</li>
          <li><strong>API TOKEN</strong>: Your Minataur API authorization token.</li>
          <li><strong>LAYOUT PARAMETERS</strong>: Adjust the layout algorithm (iterations, gravity, scale, etc.)</li>
          <li><strong>EXPORT/IMPORT</strong>: Save or load graph JSON, export image.</li>
          <li><strong>LEGEND</strong>: Filter graph edges by transaction type.</li>
          <li><strong>SEARCH</strong>: Look up a node by label or key fragment.</li>
        </ul>
        
        <hr style="margin: 30px 0; border: 1px solid #555;" />

        <h2 style="font-size: 20px; margin-bottom: 12px;">⚠️ Important note on graph complexity</h2>
        <p style="font-size: 16px; line-height: 1.6;">
          The size of the graph grows exponentially based on the combination of:
        </p>
        <ul style="font-size: 16px; line-height: 1.8;">
          <li><strong>FIRST ITERATION LIMIT (F)</strong>: Number of transactions fetched for the root key.</li>
          <li><strong>LIMIT (L)</strong>: Max transactions per linked account.</li>
          <li><strong>DEPTH (D)</strong>: How many recursive levels of linked accounts are explored.</li>
        </ul>
        <p style="font-size: 16px; line-height: 1.6;">
          Estimated number of nodes (accounts):<br />
          <code>N ≈ 1 + F × (L<sup>D</sup> – 1) / (L – 1)</code>
        </p>
        <p style="font-size: 16px; line-height: 1.6;">
          This means the graph can reach tens of thousands of nodes if values are too high.<br />
          It can impact memory, loading time, layout performance, and browser responsiveness.
        </p>

        <p style="font-size: 16px; line-height: 1.6;">
          For a smooth experience, try values like:
        </p>
        <ul style="font-size: 16px; line-height: 1.8;">
          <li><strong>Safe defaults</strong>: F = 100, L = 20, D = 2</li>
          <li><strong>Deeper graph (heavy)</strong>: F = 200, L = 30, D = 3+</li>
          <li><strong>Shallow & fast</strong>: F = 50, L = 10, D = 1</li>
        </ul>
    </div>

     <!-- Get Token Help overlay -->
    <div id="token-help-overlay">
      <button onclick="document.getElementById('token-help-overlay').style.display='none'" style="
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        color: white;
        border: 2px solid white;
        font-size: 18px;
        padding: 8px 16px;
        cursor: pointer;
        border-radius: 5px;
      ">CLOSE</button>
        <h1>🔑 How to get your API Token</h1>
        <p style="font-size: 18px; line-height: 1.6;">
          This app needs an API token to fetch transactions from the selected blockchain.<br />
          Here's how to get a token depending on the blockchain you're using:
        </p>

        <hr style="margin: 20px 0; border: 1px solid #555;" />

        <h2 style="color:#4fc3f7">🪶 Mina (Minataur)</h2>
        <p style="font-size: 16px; line-height: 1.6;">
          <strong>No token required during the trial period.</strong><br />
          However, once the trial period is over, for authenticated requests, you'll need a minataur token you can obtain by following these steps :
        </p>
        <ol style="font-size: 16px; line-height: 1.8;">
          <li>Head over <a href="https://minataur.net/api/restful" target="_blank" style="color:#4fc3f7">Minataur.net</a></li>
          <li>Follow the instructions to receive your token by email</li>
          <li>Copy your Minataur API token</li>
        </ol>
        <p style="font-size: 16px; line-height: 1.6;">
          You can also send the transaction directly through Mina Graph Explorer by entering the email address where you want to receive your token, and using Auro Wallet to send 1 MINA to the Minataur API service.
          Mina Graph Explorer (and myself) does not take any commission on this transaction !
          The transaction is as safe as it can be.
        </p>       
        <p>
          📄 <a href="https://minataur.net/api/restful" target="_blank" style="color:#4fc3f7">Read Minataur API Docs</a>
        </p>

        <hr style="margin: 30px 0; border: 1px solid #555;" />

        <h2 style="color:#4fc3f7">🟣 Polygon (Polygonscan)</h2>
        <ol style="font-size: 16px; line-height: 1.8;">
          <li>Visit <a href="https://polygonscan.com/register" target="_blank" style="color:#4fc3f7">Polygonscan Register</a> and create an account</li>
          <li>Go to your <a href="https://polygonscan.com/myapikey" target="_blank" style="color:#4fc3f7">API Keys page</a></li>
          <li>Click “+ Add” to generate a new API key</li>
          <li>Copy the key and paste it in the “API KEY” field</li>
        </ol>
        <p>
          📊 <strong>Free Tier:</strong> 5 calls/sec, 100,000/day<br />
          📄 <a href="https://docs.polygonscan.com/" target="_blank" style="color:#4fc3f7">View Polygonscan API Docs</a>
        </p>

        <hr style="margin: 30px 0; border: 1px solid #555;" />

        <h2 style="color:#4fc3f7">🟡 Ethereum (Etherscan)</h2>
        <ol style="font-size: 16px; line-height: 1.8;">
          <li>Visit <a href="https://etherscan.io/register" target="_blank" style="color:#4fc3f7">Etherscan Register</a> and create an account</li>
          <li>Navigate to <a href="https://etherscan.io/myapikey" target="_blank" style="color:#4fc3f7">API Keys</a></li>
          <li>Click “Add” to create a new API token</li>
          <li>Use the key in your request field</li>
        </ol>
        <p>
          ⛽ <strong>Free Tier:</strong> 5 calls/sec, 100,000/day<br />
          📄 <a href="https://docs.etherscan.io/" target="_blank" style="color:#4fc3f7">Check Etherscan API Docs</a>
        </p>

        <hr style="margin: 30px 0; border: 1px solid #555;" />

        <p style="font-size: 16px; line-height: 1.6;">
          ⚠️ Rate limits may apply depending on your tier or usage.<br />
          You can upgrade your plans on each explorer site for higher throughput if needed.
        </p>
    </div>

    <footer style="font-size: 12px; color: #888; text-align: center; border-top: 1px solid #333; padding-top: 10px;">
      &copy; naamahdaemon – <a href="https://mina.naamahdaemon.eu" target="_blank" style="color: #4fc3f7; text-decoration: none;">mina.naamahdaemon.eu</a><br/>
      Minataur API by Serhii Pimenov - <a href="https://minataur.net/api/restful" target="_blank" style="color: #4fc3f7; text-decoration: none;">minataur.net/api/restful</a>
    </footer>  
  

 
  <script>
    const { Graph } = graphology;
    let currentTheme = "dark"; // 👈 Declare it globally so reducers and other functions can use it
    let API_TOKEN = "minataur-token:your_minataur_token_here";
    let BASE_KEY = "B62...";
    let LIMIT = 10;
    let FIRST_ITERATION_LIMIT = 10;
    let DEPTH = 2;
    const GRAVITY = 0.1;
    const SCALINGRATIO = 1000;
    const WIDTH = 3000;
    const HEIGHT = 3000;
    const visitedKeys = new Set();
    const nameColorMap = new Map();
    let transactionsByNeighbor = {};
    
    let totalSteps = 0;
    let currentStep = 0;
    let pause = false;
    let layoutInterval = null;
    let graph, renderer;

    let hoveredNode = null;
    let searchQuery = "";
       
    let selectedNode = null;
    
    //let commandTypeFilter = null;
    const commandTypeFilter = new Set(); // allows multiple command types

    let showAllLabels = true;
    
    let selectedBlockchain = "mina"; // 👈 default value
    const delayByBlockchain = {
      mina: 0,
      ethereum: 300,
      polygon: 1000,
    };
    
    let cancelRequested = false;

    let isLayoutRunning = false;

    const tooltip = document.getElementById("tooltip");
    const panel = document.getElementById("side-panel");
    const details = document.getElementById("node-details");

    let layoutWorker;

    let currentLayout = null;  // the one currently running
    let previousLayout = null;
    

    //initRenderer();
    
    document.getElementById("start-graph-btn").addEventListener("click", () => {
      // Read values from input fields
      LIMIT = parseInt(document.getElementById("param-limit").value, 10);
      FIRST_ITERATION_LIMIT = parseInt(document.getElementById("param-first-iteration").value, 10);
      DEPTH = parseInt(document.getElementById("param-depth").value, 10);
      BASE_KEY = document.getElementById("param-base-key").value.trim();
      API_TOKEN = document.getElementById("param-api-token").value.trim();

      // Reset visited keys
      visitedKeys.clear();

      // Launch the graph builder
      main(DEPTH).catch(console.error);
      
      // 👉 Hide the sidebar after launching
      const sidebar = document.getElementById("left-sidebar");
      const appContainer = document.getElementById("app-container");
      sidebar.classList.remove("open");
      appContainer.classList.remove("sidebar-open");      
      // 👇 Reposition legend
      updateLegendOffset();      
    });

    //main(DEPTH).catch(console.error);
 
    function getExplorerURL(type, value, blockchain) {
      const explorerMap = {
        mina: {
          block: `https://minascan.io/mainnet/block/${value}/txs`,
          transaction: `https://minascan.io/mainnet/tx/${value}/txInfo`,
          account: `https://minascan.io/mainnet/account/${value}`,
        },
        ethereum: {
          block: `https://etherscan.io/block/${value}`,
          transaction: `https://etherscan.io/tx/${value}`,
          account: `https://etherscan.io/address/${value}`,
        },
        polygon: {
          block: `https://polygonscan.com/block/${value}`,
          transaction: `https://polygonscan.com/tx/${value}`,
          account: `https://polygonscan.com/address/${value}`,
        },
      };

      const chain = blockchain?.toLowerCase?.();
      return explorerMap[chain]?.[type] || "#";
    }

  </script>

  <button id="exit-fullscreen-btn" style="
    display: none;
    position: fixed;
    top: 20px;
    right: 30px;
    z-index: 99;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    border: none;
    padding: 10px 16px;
    font-size: 14px;
    border-radius: 6px;
    cursor: pointer;
  ">
    ⛶ Exit Fullscreen
  </button>  
  
  <div id="legend" class="legend-box">
    <strong>Legend</strong><br />
    <div class="legend-item" data-command-type="payment" style="color:#4caf50; cursor:pointer;">● Payment</div>
    <div class="legend-item" data-command-type="delegation" style="color:#2196f3; cursor:pointer;">● Delegation</div>
    <div class="legend-item" data-command-type="zkapp" style="color:#9c27b0; cursor:pointer;">● zkApp</div>
    <div class="legend-item" data-command-type="" style="color:#aaa; cursor:pointer; margin-top: 6px;">✖ Reset</div>
  </div>
  
  <script>
  //const commandTypeFilter = new Set();

  const commandTypeAliases = {
    payment: ["payment", "transfer"],
    zkapp: ["zkapp", "contract_call"],
    delegation: ["delegation"]
  };

  // Reverse map: actual command types → legend alias(es)
  const expandedCommandTypeFilter = () => {
    const expanded = new Set();
    commandTypeFilter.forEach(alias => {
      const realTypes = commandTypeAliases[alias] || [alias];
      realTypes.forEach(t => expanded.add(t));
    });
    return expanded;
  };

    document.querySelectorAll('.legend-item').forEach(item => {
      item.addEventListener('click', () => {
        const type = item.getAttribute('data-command-type');

        if (!type) {
        // Reset filter
          commandTypeFilter.clear();
        console.log("🔄 Filter reset");
      } else {
        const aliases = commandTypeAliases[type] || [type];
        const isActive = aliases.every(t => commandTypeFilter.has(t));

        if (isActive) {
          // Remove all aliases
          aliases.forEach(t => commandTypeFilter.delete(t));
          console.log("❌ Removed aliases:", aliases);
        } else {
          // Add all aliases
          aliases.forEach(t => commandTypeFilter.add(t));
          console.log("✅ Added aliases:", aliases);
        }
        }

      // Update visual state
        document.querySelectorAll('.legend-item').forEach(el => {
          const t = el.getAttribute('data-command-type');
        if (!t) {
          el.classList.remove('active');
          return;
        }

        const aliases = commandTypeAliases[t] || [t];
        const active = aliases.every(type => commandTypeFilter.has(type));
        el.classList.toggle('active', active);
        });

      console.log("🧪 Final filter set:", Array.from(commandTypeFilter));
        renderer.refresh();
      });
    });
  </script>  
  
  <script>
    document.getElementById("import-json").addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (file) {
        importJSON(file);
      }
    });
   </script>
   
   <script>
    document.getElementById("toggle-labels").addEventListener("change", (e) => {
      showAllLabels = e.target.checked;
      renderer.refresh();
    });
    
    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("stop-loading-btn").addEventListener("click", () => {
        cancelRequested = true;
        appendLoaderLog("⚠️ Loading cancelled by user.");
      });
      

      const toggleBtn = document.getElementById("search-icon");
      const searchDiv = document.getElementById("searchdiv");
      const searchInput = document.getElementById("search-input");
      const blockchainSelect = document.getElementById("blockchain-select");
      

      toggleBtn.addEventListener("click", (e) => {
        e.stopPropagation(); // prevent bubbling to the outside click
        const isVisible = searchDiv.style.display === "block";

        if (isVisible) {
          searchDiv.style.display = "none";
        } else {
          searchDiv.style.display = "block";
          searchInput.style.display = "block"; // optional safeguard
          searchInput.focus();
        }
      });

      // Hide on outside click
      document.addEventListener("click", (e) => {
        if (!searchDiv.contains(e.target) && !toggleBtn.contains(e.target)) {
          searchDiv.style.display = "none";
        }
      });
      
      const algorithmSelect = document.getElementById("layout-algorithm");
      const faSettings = document.getElementById("forceatlas-settings");
      const ordSettings = document.getElementById("openord-settings");

      algorithmSelect.addEventListener("change", () => {
        const value = algorithmSelect.value;
        faSettings.style.display = value === "fa" ? "block" : "none";
        ordSettings.style.display = value === "ord" ? "block" : "none";
      });
            
      if (blockchainSelect) {
        // Ensure selectedBlockchain is synced with current value on page load
        selectedBlockchain = blockchainSelect.value;
        console.log("🌐 Initial selected blockchain:", selectedBlockchain);      
        blockchainSelect.addEventListener("change", (e) => {
          selectedBlockchain = e.target.value;
          console.log("🌐 Selected blockchain:", selectedBlockchain);
        });
      }
            
    });    
   </script>

   <script>
    document.addEventListener("DOMContentLoaded", () => {
      const sidebar = document.getElementById("left-sidebar");
      const appContainer = document.getElementById("app-container");

      if (window.innerWidth >= 769) {
        sidebar.classList.add("open"); // 👈 Ajoute cette ligne !
        appContainer.classList.add("sidebar-open");
      }

      if (window.innerWidth >= 769 && sidebar.classList.contains("open")) {
        appContainer.classList.add("sidebar-open");
      } else {
      appContainer.classList.remove("sidebar-open");
      }

      // Select all inputs inside the sidebar
      const inputs = sidebar.querySelectorAll("input, select, textarea");

      inputs.forEach(input => {
        input.addEventListener("focus", () => {
            sidebar.classList.add("open");
          appContainer.classList.add("sidebar-open"); // ✅ Keep it for all screen sizes
        });
      });
      
      /*document.getElementById("menu-toggle").addEventListener("click", () => {
        const sidebar = document.getElementById("left-sidebar");
        sidebar.classList.toggle("open");
        const app = document.getElementById("app-container");
        if (window.innerWidth >= 769) {
          if (sidebar.classList.contains("open")) {
            app.classList.add("sidebar-open");
          } else {
            app.classList.remove("sidebar-open");
          }
        }     
      });*/

      document.getElementById("close-panel-btn").addEventListener("click", () => {
        document.getElementById("side-panel").classList.remove("open");
      });
      
      updateSlicerView(); // ⬅️ initial call
    });    
    
    function updateSlicerView() {
      const slicerContainer = document.getElementById("date-slicer-container");
      const slicerInner = document.getElementById("slicer-container");
      const chartCanvas = document.getElementById("slicer-chart");
      const labels = slicerContainer.querySelectorAll("#slicer-start-label, #slicer-end-label");
      const slider = document.getElementById("slicer-range");
      const isMobile = window.innerWidth <= 768;

      if (isMobile) {
        document.body.classList.add("mobile-mode");

        if (chartCanvas) {
          chartCanvas.style.display = "none";
          chartCanvas.style.height = "0";
      }
      
        if (slicerInner) {
          slicerInner.style.height = "auto";
        }

        if (slicerContainer) {
          // 🧹 Clear any stale inline height or display
          slicerContainer.style.removeProperty("height");
          slicerContainer.style.removeProperty("display");

          // ✅ Force mobile layout re-apply
          slicerContainer.style.height = "auto";
      slicerContainer.style.display = "block";      
        }

        labels.forEach(label => label.style.display = "none");
      } else {
        document.body.classList.remove("mobile-mode");
     
        if (chartCanvas) {
          chartCanvas.style.display = "block";
          chartCanvas.style.height = "150px";
        }

        if (slicerInner) {
          slicerInner.style.height = "140px";
        }

        labels.forEach(label => label.style.display = "inline-block");

        slicerContainer.style.display = "block";
        slicerContainer.style.height = "auto";
      }
     
      // Slider refresh or rebuild
      if (slider && slider.noUiSlider) {
        try {
          slider.noUiSlider.refresh?.(); // Optional chaining for non-standard APIs
        } catch (err) {
          console.warn("⚠️ noUiSlider.refresh failed, reinitializing...");

          try {
            if (!Array.isArray(allTimestamps) || allTimestamps.length < 2) {
              console.error("❌ allTimestamps are invalid, cannot rebuild slider.");
              slicerContainer.style.display = "none";
              return;
            }

            const values = slider.noUiSlider.get();
            const min = allTimestamps[0];
            const max = allTimestamps[allTimestamps.length - 1];

          slider.noUiSlider.destroy();
            slider.innerHTML = "";

            setTimeout(() => {
          noUiSlider.create(slider, {
            start: values.map(v => parseInt(v)),
            connect: true,
                range: { min, max },
                step: 24 * 60 * 60 * 1000,
            format: {
              to: value => Math.round(value),
              from: Number
            }
          });

              //console.log("✅ noUiSlider reinitialized");

              slider.noUiSlider.on("update", function (values) {
                currentRange = values.map(v => parseInt(v));
                applyDateFilter();
              });

              applyDateFilter();

            }, 50);
          } catch (e2) {
            console.error("🔥 Rebuild of noUiSlider failed:", e2);
          }
        }
      }
    }

    window.addEventListener("resize", updateSlicerView);
    window.addEventListener("DOMContentLoaded", updateSlicerView);   
    window.addEventListener("orientationchange", () => {
      setTimeout(updateSlicerView, 300);
    });
   </script>   
   
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const toggleBtn = document.getElementById("theme-toggle-btn");

      function applyTheme(theme) {
        currentTheme = theme;
        const isLight = theme === "light";

        // Update button text
        const iconContainer = document.getElementById("theme-icon");
        iconContainer.innerHTML = isLight
          ? `
            <!-- Sun -->
            <svg viewBox="0 0 24 24" width="24" height="24" style="fill:white;">
              <path fill="black" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"/>
            </svg>
          `
          : `
            <!-- Moon -->
            <svg viewBox="0 0 24 24" width="24" height="24" style="fill:white;">
              <path fill="white" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"/>
            </svg>
          `;

        const searchIconSvg = document.getElementById("search-icon-svg");
        if (searchIconSvg) {
          searchIconSvg.setAttribute("fill", isLight ? "black" : "white");
        }

        // Apply styles only if elements exist
        document.body.style.background = isLight ? "#f5f5f5" : "#000";

        const sidebar = document.getElementById("left-sidebar");
        if (sidebar) {
          sidebar.style.background = isLight ? "#fff" : "#1e1e1e";
          sidebar.style.color = isLight ? "#111" : "#fff";
        }

        const controls = document.getElementById("controls");
        if (controls) {
          controls.style.background = isLight ? "#eee" : "#222";
          controls.style.color = isLight ? "#000" : "#fff";
        }

        const footer = document.getElementById("footer");
        if (footer) {
          footer.style.color = isLight ? "#333" : "#aaa";
          footer.style.borderTop = isLight ? "1px solid #aaa" : "1px solid #333";
        }

        const sigmaContainer = document.getElementById("sigma-container");
        if (sigmaContainer) {
          sigmaContainer.style.background = isLight ? "#fff" : "#000";
        }

        document.querySelectorAll("#left-sidebar input, #controls input").forEach(input => {
          input.style.background = isLight ? "#fff" : "#222";
          input.style.color = isLight ? "#000" : "#fff";
        });

        // Apply to Sigma renderer
        if (typeof renderer !== "undefined") {
          //console.log("Inside applyTheme");
          renderer.setSetting("labelColor", {color: isLightTheme() ? "#000" : "#9999ff"});
          renderer.setSetting("labelBackground", {color: isLightTheme() ? "#fff" : "#000"});
          //console.log(isLight ? "Label Color switched to #000" : "Label Color switched to #fff");
          renderer.setSetting("defaultNodeColor", isLight ? "#444" : "#ccc");
          renderer.setSetting("defaultEdgeColor", isLight ? "#aaa" : "#555");
          renderer.refresh();
          renderer.render();
        }
      }

      toggleBtn?.addEventListener("click", () => {
        applyTheme(currentTheme === "dark" ? "light" : "dark");
        setupReducers(); // 👈 Ajout essentiel
        renderer.refresh(); // 👈 Pour forcer le redraw après les nouveaux reducers
        renderer.render();
      });


      applyTheme("dark"); // init
    });
  </script>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const tokenInput = document.getElementById("param-api-token");

      // Charger le token depuis localStorage s’il existe
      const savedToken = localStorage.getItem("minataurToken");
      if (savedToken) tokenInput.value = savedToken;

      // Sauvegarder à chaque changement
      tokenInput.addEventListener("input", () => {
        localStorage.setItem("minataurToken", tokenInput.value);
      });

      const layoutBtn = document.getElementById("layout-toggle-btn");

      layoutBtn.addEventListener("click", () => {
        if (isLayoutRunning) {
          stopLayoutInWorker();
          layoutBtn.textContent = "Apply Layout";
          isLayoutRunning = false;
        } else {
          runLayoutInWorker();
          layoutBtn.textContent = "Stop Layout";
          isLayoutRunning = true;
        }
      });    
    });
  </script>
  <script type="module">
    import bs58 from 'https://cdn.skypack.dev/bs58';

    function encodeMemoToBase58(memo) {
      const bytes = new TextEncoder().encode(memo);
      return bs58.encode(bytes);
    }

    // Make function globally available if needed
    window.encodeMemoToBase58 = encodeMemoToBase58;
  </script>

  <script>
    const MINATAUR_API_ADDRESS = "B62qk3SwELMgRYALi8fiQvpqfBs48m3cqCd7o4d5dJUqEQ6mW9gEySm";

    async function connectAuroAndSend() {
      const email = document.getElementById("minataur-email").value.trim();
      if (!email || !email.includes("@")) {
        alert("Merci d'entrer un email valide");
        return;
      }

      if (!window.mina) {
        alert("Auro Wallet n'est pas détecté. Installez-le depuis https://www.aurowallet.com/");
        return;
      }

      try {
        const accounts = await window.mina.requestAccounts();
        const publicKey = accounts[0];
        console.log("Wallet connecté :", publicKey);

        // Construction transaction
        const { hash } = await window.mina.sendPayment({
          to: MINATAUR_API_ADDRESS,
          amount: "1.0",
          fee: "0.01",
          memo: email
        });

        alert("Transaction envoyée ! Hash : " + hash + "\nVotre token arrivera bientôt par email.");

        // Fold the section after success
        const tokenSection = document.getElementById("minataur-token-section");
        const arrow = document.getElementById("toggle-token-arrow");
        tokenSection.style.display = "none";
        if (arrow) arrow.textContent = "▸";
      } catch (err) {
        console.error("Erreur avec Auro :", err);
        alert("Erreur lors de l'envoi : " + err.message);
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      const toggleBtn = document.getElementById("toggle-token-section");
      const arrow = document.getElementById("toggle-token-arrow");
      const tokenSection = document.getElementById("minataur-token-section");

      toggleBtn?.addEventListener("click", () => {
        const isHidden = tokenSection.style.display === "none";
        tokenSection.style.display = isHidden ? "block" : "none";
        arrow.textContent = isHidden ? "▾" : "▸";
      });

      document.getElementById("connect-auro-btn")?.addEventListener("click", connectAuroAndSend);
    });
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const sidebar = document.getElementById("left-sidebar");
      const appContainer = document.getElementById("app-container");
      const sigmaContainer = document.getElementById("sigma-container");
      

      function adjustSidebarState() {
        if (window.innerWidth >= 769) {
          sidebar.classList.add("open");
          appContainer.classList.add("sidebar-open");
        }

        updateLegendOffset(); // 👈 met aussi à jour la légende
      }

      adjustSidebarState(); // Appel initial

      // Responsive: surveille resize
      // ✅ Resize Sigma on window resize
      window.addEventListener("resize", () => {
        adjustSidebarState();
        updateLegendOffset();
        if (renderer) {
          renderer.resize();
          renderer.refresh();
        }
      });

      // ✅ Resize Sigma if #sigma-container itself is resized (e.g. flexbox, sidebar toggle, etc.)
      const resizeObserver = new ResizeObserver(() => {
        if (renderer) {
          renderer.resize();
          renderer.refresh();
        }
      });

      if (sigmaContainer) {
        resizeObserver.observe(sigmaContainer);
      }

      /*document.getElementById("menu-toggle").addEventListener("click", () => {
        const sidebar = document.getElementById("left-sidebar");
        sidebar.classList.toggle("open");
        const app = document.getElementById("app-container");
        if (window.innerWidth >= 769) {
          if (sidebar.classList.contains("open")) {
            app.classList.add("sidebar-open");
          } else {
            app.classList.remove("sidebar-open");
          }
        }     
      });*/

      document.getElementById("menu-toggle").addEventListener("click", () => {
        sidebar.classList.toggle("open");
        appContainer.classList.toggle("sidebar-open");
        updateLegendOffset();
        
        // Give layout time to settle before resizing Sigma
        setTimeout(() => {
          if (renderer) {
            renderer.resize();
            renderer.refresh();
          }
        }, 150);        
      });

      // Close side panel (right panel)
       document.getElementById("close-panel-btn").addEventListener("click", () => {
        document.getElementById("side-panel").classList.remove("open");
      });
    });
  </script>

  <script>
    const DONATION_ADDRESS = "B62qrZNc5YzuBzSaCPSNRASCkPjKosaj3zYZELM6X5nCsha6rEh6s8F";

    async function sendDonation() {
      const amount = parseFloat(document.getElementById("donation-amount").value);
      if (!amount || amount <= 0) {
        alert("Please enter a valid donation amount (at least 0.1 MINA).");
        return;
      }

      if (!window.mina) {
        alert("Auro Wallet not detected. Please install it from https://www.aurowallet.com/");
        return;
      }

      try {
        const accounts = await window.mina.requestAccounts();
        const sender = accounts[0];
        console.log("Donating from:", sender);

        const { hash } = await window.mina.sendPayment({
          to: DONATION_ADDRESS,
          amount: amount.toString(),
          fee: "0.01",
          memo: "Thanks for Mina Graph!"
        });

        alert("Thanks for your donation! Tx hash: " + hash);
      } catch (err) {
        console.error("Donation error:", err);
        alert("Error while sending donation: " + err.message);
      }
    }

    document.getElementById("donate-btn").addEventListener("click", sendDonation);
  </script>

<script>
  const sidebar = document.getElementById("left-sidebar");
  const controls = document.getElementById("controls");
  const footer = document.querySelector("footer");
  const fullscreenBtn = document.getElementById("fullscreen-toggle");
  const sigmaContainer = document.getElementById("sigma-container");
  const exitFullscreenBtn = document.getElementById("exit-fullscreen-btn");
  const appContainer = document.getElementById("app-container");
  let isFullscreen = false;

  function toggleFullscreen(forceExit = false) {
    isFullscreen = forceExit ? false : !isFullscreen;
    const legend = document.getElementById("legend");
    const menu = document.getElementById("menu-toggle");

    if (isFullscreen) {
      sidebar.style.display = "none";
      controls.style.display = "none";
      if (footer) footer.style.display = "none";
      appContainer.classList.remove("sidebar-open"); // 👈 remove margin
      //sidebar.classList.remove("open"); // 👈 remove margin
      fullscreenBtn.textContent = "Exit Fullscreen";
      exitFullscreenBtn.style.display = "block";
      document.body.classList.add("fullscreen-mode");
      legend.style.left = "50px";
      menu.style.display="none"
    } else {
      sidebar.style.display = "block";
      controls.style.display = "flex";
      if (footer) footer.style.display = "block";
      menu.style.display="block"

      // 👇 Only add sidebar-open on desktop
      if (window.innerWidth >= 769 && sidebar.classList.contains("open")) {
        appContainer.classList.add("sidebar-open");
        legend.style.left = "330px"; // sidebar + margin
      } else { 
        appContainer.classList.remove("sidebar-open");
        legend.style.left = "50px";
      }

      fullscreenBtn.textContent = "⛶";
      exitFullscreenBtn.style.display = "none";
      document.body.classList.remove("fullscreen-mode");
      updateLegendOffset(); // 👈 and here too
    }
  }

  fullscreenBtn.addEventListener("click", () => toggleFullscreen());
  exitFullscreenBtn.addEventListener("click", () => toggleFullscreen(true));
  window.dispatchEvent(new Event("resize"));  
</script>

  <script>
    let allTimestamps = [];  // 🔁 collected from edges
    let currentRange = [0, 0];
    let histogramChart;

    function setupDateSlicer() {
      if (!graph || !graph.edges) return;

      const timestamps = graph.edges().map(id => {
        const ts = graph.getEdgeAttribute(id, "timestamp");
        return typeof ts === "string" ? parseInt(ts) : ts;
      }).filter(t => !isNaN(t)).sort((a, b) => a - b);

      if (!timestamps.length) return;

      allTimestamps = timestamps;

      const minTimestamp = Math.min(...timestamps);
      const maxTimestamp = Math.max(...timestamps);
      const binCount = 20;
      const binSize = Math.ceil((maxTimestamp - minTimestamp) / binCount);
      currentRange = [minTimestamp, maxTimestamp];

      const bins = new Array(binCount).fill(0);
      timestamps.forEach(ts => {
        const index = Math.min(Math.floor((ts - minTimestamp) / binSize), binCount - 1);
        bins[index]++;
      });

      const ctx = document.getElementById("slicer-chart").getContext("2d");
      if (histogramChart) histogramChart.destroy();

      histogramChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: bins.map((_, i) => {
            const d = new Date(minTimestamp + i * binSize);
            return d.toLocaleDateString(); // or d.toISOString().slice(0, 10)
          }),
          datasets: [{
            label: 'Tx Count',
            data: bins,
            backgroundColor: '#4fc3f7'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                title: (tooltipItems) => {
                  const index = tooltipItems[0].dataIndex;
                  const startDate = new Date(minTimestamp + index * binSize);
                  const endDate = new Date(minTimestamp + (index + 1) * binSize);
                  return `${startDate.toLocaleDateString()} – ${endDate.toLocaleDateString()}`;
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Transaction Date'
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Count'
              }
            }
          }
        }
      });

      // Create noUiSlider range control
      const slider = document.getElementById("slicer-range");
      slider.innerHTML = ""; // Clear any previous

      // 💥 Prevent re-initialization
      if (slider.noUiSlider) {
        slider.noUiSlider.destroy();
      }

      noUiSlider.create(slider, {
        start: [minTimestamp, maxTimestamp],
        connect: true,
        range: {
          min: minTimestamp,
          max: maxTimestamp
        },
        step: 24 * 60 * 60 * 1000, // 1 day in ms
        tooltips: [false, false], // start with no tooltip
        format: {
          to: value => Math.round(value),
          from: Number
        }
      });

      const handles = slider.querySelectorAll('.noUi-handle');

      // On drag start: add tooltip divs
      slider.noUiSlider.on("start", () => {
        handles.forEach((handle, i) => {
          if (!handle.querySelector('.tooltip')) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.style.position = 'absolute';
            tooltip.style.top = '-28px';
            tooltip.style.left = '50%';
            tooltip.style.transform = 'translateX(-50%)';
            tooltip.style.background = '#000';
            tooltip.style.color = '#fff';
            tooltip.style.padding = '2px 6px';
            tooltip.style.borderRadius = '4px';
            tooltip.style.fontSize = '11px';
            tooltip.style.whiteSpace = 'nowrap';
            tooltip.style.pointerEvents = 'none';
            tooltip.style.opacity = '0.9';
            handle.appendChild(tooltip);
          }
        });
      });

      // On slide: update tooltip content
      slider.noUiSlider.on("slide", (values) => {
        handles.forEach((handle, i) => {
          const tooltip = handle.querySelector('.tooltip');
          if (tooltip) {
            tooltip.textContent = new Date(+values[i]).toLocaleDateString();
          }
        });
      });

      // On end: remove tooltips
      slider.noUiSlider.on("end", () => {
        handles.forEach(handle => {
          const tooltip = handle.querySelector('.tooltip');
          if (tooltip) tooltip.remove();
        });
      });

      // Update range filter
      slider.noUiSlider.on("update", function (values) {
        currentRange = values.map(v => parseInt(v));
        applyDateFilter(); // filter the graph dynamically
      });


      applyDateFilter(); // Initial filtering
    }


    function applyDateFilter() {
      const [min, max] = currentRange;

      const formatter = ts => new Date(ts).toLocaleDateString();
      document.getElementById("slicer-start-label").textContent = `From: ${formatter(min)}`;
      document.getElementById("slicer-end-label").textContent = `To: ${formatter(max)}`;

      graph.forEachEdge((e, attrs) => {
        const ts = parseInt(attrs.timestamp);
        const keep = ts >= min && ts <= max;
        graph.setEdgeAttribute(e, "hidden", !keep);
      });

      const visibleNodes = new Set();
      graph.forEachEdge((e) => {
        if (!graph.getEdgeAttribute(e, "hidden")) {
          visibleNodes.add(graph.source(e));
          visibleNodes.add(graph.target(e));
        }
      });

      graph.forEachNode((n) => {
        graph.setNodeAttribute(n, "hidden", !visibleNodes.has(n));
      });

      renderer.refresh();
    }

    function hideNodePanel() {
      const panel = document.getElementById("side-panel");
      const slicer = document.getElementById("date-slicer-container");
      
      document.getElementById("side-panel").classList.remove("open");

      panel.style.display = "none";
      slicer.classList.remove("on-left");

      selectedNode = null;
      renderer.refresh();
    }
  </script>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const legend = document.getElementById("legend");
      let isDragging = false;
      let offsetX = 0;
      let offsetY = 0;

      if (!legend) return;

      legend.style.cursor = "move";
      legend.style.userSelect = "none"; // prevent text selection
      legend.style.touchAction = "none"; // important for touch dragging

      const startDrag = (e) => {
        isDragging = true;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        offsetX = clientX - legend.offsetLeft;
        offsetY = clientY - legend.offsetTop;
        legend.style.transition = "none";
      };

      const onDrag = (e) => {
        if (!isDragging) return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        legend.style.left = `${clientX - offsetX}px`;
        legend.style.top = `${clientY - offsetY}px`;
        if (e.cancelable) e.preventDefault(); // avoid scrolling on touch
      };

      const stopDrag = () => {
        isDragging = false;
        legend.style.transition = "";
      };

      // Mouse events
      legend.addEventListener("mousedown", startDrag);
      document.addEventListener("mousemove", onDrag);
      document.addEventListener("mouseup", stopDrag);

      // Touch events
      legend.addEventListener("touchstart", startDrag, { passive: false });
      document.addEventListener("touchmove", onDrag, { passive: false });
      document.addEventListener("touchend", stopDrag);
    });
  </script>

  <script>
    function rebuildTransactionsByNeighbor() {
      transactionsByNeighbor = {}; // ⚠️ Assure-toi que cette variable est bien déclarée globalement avec let

      graph.forEachEdge((edge, attrs, source, target) => {
        const tx = {
          sender_key: source,
          receiver_key: target,
          command_type: attrs.label,
          status: attrs.status,
          timestamp: attrs.timestamp,
          hash: edge,
          fee: attrs.fee,
          amount: attrs.amount,
          block_id: attrs.block_id,
          block_hash: attrs.block_hash,
          memo: attrs.memo,
          label: attrs.label
        };

        if (!transactionsByNeighbor[source]) transactionsByNeighbor[source] = [];
        if (!transactionsByNeighbor[target]) transactionsByNeighbor[target] = [];
   
        transactionsByNeighbor[source].push(tx);
        transactionsByNeighbor[target].push(tx);
      });
    }
  </script>
   
  <div id="loader-modal" style="
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    flex-direction: column;
    font-family: monospace;
    padding: 20px;
  ">
  
  
    <h2 style="margin-bottom: 20px;">Fetching graph data...</h2>
    <pre id="loader-log" style="
      background: #111;
      padding: 15px;
      border-radius: 6px;
      max-height: 250px;
      overflow-y: auto;
      width: 400px;
      font-size: 13px;
    "></pre>
    <button id="stop-loading-btn" style="
      margin-top: 20px;
      padding: 10px 20px;
      background: #f44336;
      border: none;
      border-radius: 4px;
      color: white;
      font-weight: bold;
      cursor: pointer;
    ">Stop</button>    
  </div>
 <div id="error-popup" style="
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #1e1e1e;
  color: white;
  padding: 30px 40px;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(0,0,0,0.6);
  z-index: 10001;
  font-family: 'Coda', sans-serif;
  text-align: center;
  max-width: 80%;
">
  <p id="error-message" style="margin-bottom: 20px; font-size: 16px;">Something went wrong with the API.</p>
  <button onclick="document.getElementById('error-popup').style.display='none'" style="
    background: #f44336;
    color: white;
    border: none;
    padding: 10px 20px;
    font-size: 14px;
    cursor: pointer;
    border-radius: 4px;
  ">Close</button>
</div>   

<div id="splash-screen">
  <div class="splash-content">
    <img src="./icons/icon-512.png" alt="MinaGraph" />
    <h1>Mina Graph Explorer</h1>
  </div>
</div>
</body>
</html>